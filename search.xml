<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机基础</title>
    <url>/2020/11/18/FundamentalsOfComputer/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="一、-操作系统"><a href="#一、-操作系统" class="headerlink" title="一、 操作系统"></a>一、 操作系统</h2><p>1.什么是内存泄漏？什么是内存溢出？二者有什么区别？<br>内存溢出（OutOfMemory-OOM）：指你的应用的内存已经不能满足正常使用了，堆栈已经达到系统设置的最大值，进而导致崩溃，这是一种结果描述。<br>内存泄漏（Memory Leak）：指你的应用使用资源之后没有及时释放，导致应用内存中持有了不需要的资源，这是一种状态描述。<br>2.了解的操作系统有哪些？<br>Windows，Unix，Linux，Mac</p>
<h2 id="二、-计算机网络"><a href="#二、-计算机网络" class="headerlink" title="二、 计算机网络"></a>二、 计算机网络</h2><p>1.什么是局域网，广域网？<br>1.1局域网<br>局域网（Local Area Network），简称LAN，是指在某一区域内由多台计算机互联成的计算机组。“某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。<br>1.2广域网<br>广域网（Wide Area Network），简称WAN，是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，甚至一个国家。广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。<br>2.10M兆宽带是什么意思？理论下载速度是多少？<br>首先我们要搞懂其中的区别，运营商说的10M，完整的单位应该是10Mbps（bps：比特率），而我们讲的下载速度单位是MB，虽然都念兆，但是不一样的。<br>它们之间的换算关系是：1MB=8×1Mbps，换个方式看：1Mbps÷8=128KB，也就是说，运营商称的10M宽带，实际速度是10Mbps÷8=1280KB，约1.25MB。<br>3.什么是IP地址？<br>IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。<br>4.OSI七层网络模型的划分？<br>4.1.简介<br>OSI七层模型，OSI为（Open System interconnect）的缩写，自上而下分别是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层<br>物理层：网卡，网线，集线器，中继器，调制解调器<br>数据链路层：网桥，交换机<br>网络层：路由器<br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer01.png" alt="img"><br>4.2物理层<br>首先，物理层并不是物理媒体本身，物理层的媒体包括电缆、光纤等。正因为物理媒体会有很多差异，所以物理层的作用正是尽可能地屏蔽这些差异，使上面的数据链路曾感觉不到这些差异。其主要任务就是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性等。在这一层，数据的单位为比特（bit）。<br>4.3数据链路层<br>数据链路层的使用的信道主要有以下两种类型：点对点信道、广播信道。<br>数据链路层的协议有很多种，但有三个基本问题则是共同的：封装成帧、透明传输、差错检测。<br>封装成帧：就是在数据前后分别添加首部和尾部，这样就构成了帧。<br>透明传输：用字节填充法（在非帧边界的控制字符插入转义字符）解决透明传输的问题。<br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer02.png" alt="img"><br>差错检测：传输过程中可能会出现差错（比特差错），为保证可靠性，在数据链路层广泛使用了循环冗余检验CRC的检错技术。<br>数据链路层的协议的代表包括PPP STP SDLC等，这一层的单位是帧。<br>4.4网络层<br>网络层的任务就是选择合适的网间路由和交换结点，数据包是包含在帧中，包中封装了网络层包头，如源站点、目的站点信息等，如果你还在讨论一个ip地址，那么你是在这层的问题。此外还有一些路由协议的地址解析协议（ARP）,网络层还可以实现拥塞控制、网际互连等，这一层，数据的单位为数据包。网络协议代表有IP IPX RIP OSPF等。<br>4.5传输层（运输层）<br>传输层是整个网络体系结构中的关键层次之一。IP数据报中的首部明确标记了两个主机的IP地址，但是“两个主机之间的通信”说法不清楚，因为真正进行通信的实体是主机中的进程。根据应用程序的不用需求，运输层需要两种不同的运输协议，即面向连接的TCP和无连接的UDP。TCP数据单元为段 而UDP中数据单元为数据报。<br>TCP 面向连接 全双工 面向字节流 每一条TCP连接有两个端点，这两个端点是什么呢？不是主机，也不是主机IP，不是应用进程，也不是运输层的协议端口。TCP链接的端点叫做套接字（socket）=IP地址：端口号<br>TCP的三次握手和四次挥手<br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer03.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer04.png" alt="img"><br>TCP的可靠传输的实现：1.滑动窗口 2.超时重传 3.选择确认 SACK<br>TCP的流量控制：滑动窗口<br>TCP的拥塞控制：慢开始与拥塞避免<br>UDP是无连接 尽最大努力交付 面向报文 首部开销小 8字节 比TCP的20个字节小<br>4.6会话层<br>会话单位的控制层，其主要功能是按照在应用进程之间约定的原则，按照正确的顺序收、发数据，进行各种形态的对话。<br>4.7表示层<br>数据表示形式的控制层，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。<br>4.8.应用层<br>OSI参考模型的最高层。其功能是实现应用进程（如用户程序、终端操作员等）之间的信息交换。同时，还具有一系列业务处理所需要的服务功能。应用层许多协议都是基于客户服务器方式。<br>5.TCP和UDP有什么不同？<br>TCP：<br>优点：可靠稳定<br>TCP的可靠体现在TCP在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认. 窗口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。<br>缺点：慢，效率低，占用系统资源高，易被攻击<br>在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制. 重传机制. 拥塞机制等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个连接都会占用系统的CPU，内存等硬件资源。因为TCP有确认机制. 三次握手机制，这些也导致TCP容易被利用，实现DOS. DDOS. CC等攻击。<br>UDP：<br>优点：快，比TCP稍安全<br>UDP没有TCP拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有TCP的这些机制，被攻击利用的机会就少一些，但是也无法避免被攻击。<br>缺点：不可靠，不稳定<br>因为没有TCP的这些机制，UDP在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失。<br>适用场景：<br>TCP：当对网络质量有要求时，比如HTTP，HTTPS，FTP等传输文件的协议；POP，SMTP等邮件传输的协议<br>UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景<br>6.HTTP属于哪一层的协议？<br>HTTP协议属于应用层协议<br>7.HTTP和HTTPS的区别？<br>安全性上的区别:HTTPS：HTTP协议的安全加强版，通过在HTTP上建立加密层，对传输数据进行加密。主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。<br>表现形式：HTTPS站点会在地址栏上显示一把绿色小锁，表明这是加密过的安全网站，如果采用了全球认证的顶级EV SSL证书的话，其地址栏会以绿色高亮显示，方便用户辨认。<br>SEO：在2015年之前百度是无法收录HTTPS页面的，不过自从2015年5月份百度搜索全站HTTPS加密后，就已经可以收录HTTPS了。谷歌则是从2014年起便开始收录HTTPS页面，并且HTTPS页面权重比HTTP页面更高。从SEO的角度来说，HTTPS和HTTP区别不大，甚至HTTPS效果更好。<br>技术层面：如果要说HTTPS和HTTP的区别，最关键的还是在技术层面。比如HTTP标准端口是80，而HTTPS标准端口是443；HTTP无需证书，HTTPS需要CA机构颁发的SSL证书；HTTP工作于应用层，HTTPS工作于传输层。<br>8.cookies和session的区别？<br>cookies:是针对每一个网站的信息，每一个网站只对应一个，其它网站不能访问，这个文件是保存在客户端的，每次你打相应网站，浏览器会查找这个网站的cookies，如果有就会将这个文件起发送出去。cookies文件的内容大致包函这些信息如用户名，密码，设置等。<br>session：是针对每一个用户的，只有客户机访问，程序就会为这个客户新增一个session。session里<br>主要保存的是用户的登录信息，操作信息等。这个session在用户访问结束后会被自动消失（如果超时也会）。<br>9.HTTP的get请求和post请求的区别？<br>（1）在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTMLHEADER内提交。<br>（2）GET方式提交的数据最多只能有1024字节，而POST则没有此限制。<br>（3）安全性问题。正如在（1）中提到，使用Get的时候，参数会显示在地址栏上，而Post不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用post为好。<br>（4）安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一URL的多个请求应该返回同样的结果。<br>10.TCP的连接建立过程，以及断开过程？<br>10.1TCP报文格式<br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer05.png" alt="img"><br>在了解三次握手和四次挥手之前，先知道TCP报文内部包含了哪些东西。<br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。TCP在发送数据前必须在彼此间建立连接，这里连接意思是：双方需要内保存对方信息（例如：IP，Port…）<br>报文主要段的意思<br>序号：表示发送的数据字节流，确保TCP传输有序，对每个字节编号<br>确认序号：发送方期待接收的下一序列号，接收成功后的数据字节序列号加 1。只有ACK=1时才有效。<br>ACK：确认序号的标志，ACK=1表示确认号有效，ACK=0表示报文不含确认序号信息<br>SYN：连接请求序号标志，用于建立连接，SYN=1表示请求连接<br>FIN：结束标志，用于释放连接，为1表示关闭本方数据流<br>10.2、“三次握手”<br>10.2.1 三次握手过程<br>建立TCP连接时，需要客户端和服务器共发送3个包。<br>第一次：客户端发送初始序号x和syn=1请求标志<br>第二次：服务器发送请求标志syn，发送确认标志ACK，发送自己的序号seq=y，发送客户端的确认序号ack=x+1<br>第三次：客户端发送ACK确认号，发送自己的序号seq=x+1，发送对方的确认号ack=y+1<br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer06.png" alt="img"><br>10.2.2 三次握手过程分析：<br>第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x<br>第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y<br>第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1<br>上面分析过程可以看出，握手两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论的。<br>10.3 “四次挥手”<br>10.3.1 四次挥手过程<br>第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态<br>第二次挥手：服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态<br>第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）<br>第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态<br><img src= "/img/loading.gif" data-src="/images/FundamentalsOfComputer07.png" alt="img"><br>10.3.2四次挥手过程分析<br>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1<br>具体可参考：<a href="https://baijiahao.baidu.com/s?id=1654225744653405133&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1654225744653405133&amp;wfr=spider&amp;for=pc</a><br>11.常用协议端口号SSH、DHCP、HTTP、FTP、SMTP、DNS等<br>12.客户端使用DHCP获取IP的过程？<br>发现阶段：即DHCP客户端寻找DHCP服务器的阶段。<br>提供阶段：即DHCP服务器提供IP地址的阶段。<br>选择阶段：即DHCP客户端选择某台DHCP服务器提供的IP地址的阶段。<br>确认阶段：即DHCP服务器确认所提供的IP地址的阶段。<br>13.写出某个网段的网络地址和广播地址？<br>算法：<br>子网掩码与IP地址进行位与运算，得处网络地址<br>网络地址| (~ 子网掩码 )，得出广播地址（| ：位或运算 ； ~ ：按位取反）<br>例如：<br>IP地址10.145.129.20，掩码255.255.248.0，网络地址和广播地址怎么计算？<br>网络地址10.145.128.0 广播地址10.145.135.255<br>解答：<br>IP转换成二进制：00001010 10010001 10000001 00010010<br>掩码转换成二进制：11111111 11111111 11111000 00000000<br>IP与掩码相与得网络地址（全1为1，见0为0）：00001010 10010001 10000000 00000000<br>网络地址转换成十进制为：10,145,128,0<br>看你的掩码把后24位的前13为划成了子网，后11为划成了主机，故：<br>广播地址则要把网络地址的主机位全换成1,得：00001010,10010001,10000111,1111111<br>广播地址转换成十进制为：10,145,135,255<br>首先由ip地址结合子网掩码可以看出的是这是一个由A类地址，“借用”13位的主机位而得到的子网，所以很轻易地得到网络地址是：10.145.128.0，也即：00001010.10010001.10000 000.00000000（前21（8+13）位是网络位，后11位是主机位）。至于广播地址，网络位+全为1的主机位，即得：00001010.10010001.10000 111.11111111，10进制表达方式就是10.145.135.255<br>14.什么是VPN都有什么类型？<br>VPN的隧道协议主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做本地化测试</title>
    <url>/2020/11/18/HowToDoLocalizationTest/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="一、什么是本地化测试"><a href="#一、什么是本地化测试" class="headerlink" title="一、什么是本地化测试"></a>一、什么是本地化测试</h2><p>当今的软件发布到世界不同的国家和地区，使软件适应该国家或地区特定的语言、地区习俗和文化的过程成为本地化，这类的测试就称为本地化测试</p>
<h2 id="二、本地化测试包括哪些内容"><a href="#二、本地化测试包括哪些内容" class="headerlink" title="二、本地化测试包括哪些内容"></a>二、本地化测试包括哪些内容</h2><p>1） 翻译<br>这是最基本的内容，首先检查软件中显示的文字、帮助文档的内容等等是否翻译成当地的语言，并且能够被读懂。这并不是说要求测试小组中的每一个人都会当地的语言，只需要一人会就行了，不会的人可以检查本地化的其他方面。<br>2）文本扩展<br>当英文翻译为其他语言时，翻译的内容长度可能增加很多，这称为文本扩展。文本扩展会导致一些问题，例如窗口中的按钮文本截断，没有换行，或者按钮长度自动扩展导致窗口布局发生很大变化等等；有时还会导致系统崩溃，如对于文本分配的内存容纳英文文本是足够的，但是对于其他语言文本就不够了。<br>3）字符编码问题<br>有些软件使用代码页和DBCS（双字节字符集）提供对不同语言的支持，有些情况下会出现问题，例如没有代码页之间转换，显示的字符就会乱七八糟。<br>4）热键和快捷键<br>在本地化测试中需要测试所有的热键和快捷键能否正常工作，符合当地习惯。例如英文的Search翻译成法语是Rechercher，英文中热键是Alt+S，在法语中应该变为Alt+R<br>5）扩展字符<br>所谓扩展字符是指在普通英文字符A-Z和a-z之外的字符，例如许多键盘上看不见的象形字符。对这类的测试是，在所有接受输入和输出之处，尝试使用扩展字符，看能否像普通字符一样处理，如能否正常显示、打印，在程序之间复制粘贴会怎样<br>6）排序、大小写<br>不同的语言对排序规则不同，对于有些亚洲地区，排序是按字符笔画排序，欧美地区一般按字母顺序排序。另外，对于大小写问题，ASCII字符通过+/-32进行大小写转换，如果使用同样的方法处理其他语言，就很可能出错。<br>7）从左到右和从右到左读<br>有些语言，如阿拉伯文，是从右向左读，这个需要注意<br>8）图形中的文字<br>有些菜单中采用字符作为图标，例如使用B作为加粗，英文中是BOLD的首字母没有问题，如果在其他语言中，对于不懂英文的人，这个就可能是个问题，需要对图标进行改变。<br>9）字符串连接的问题<br>当前很多软件将要翻译的内容放到源代码之外的独立文件中，称为资源文件，当动态生成提示信息时，可能用一些文本碎片拼成一个大的提示信息，对英文来说没有问题，但是对于其他语言，由于文字顺序不一样，拼在一起就会错误。<br>10）内容<br>对一个国家是正确的内容，换到另一个国家就可能是完全错误的，需要仔细检查翻译的内容中适应符合当地的地区。例如对于有些国家是左侧行驶对的，但同样的内容在其他国家需要修改为右侧行驶才是对的。<br>11）数据格式<br>包括度量单位、日期、时间、电话号码、纸张大小等等，不同的国家使用不同的格式，除了检查格式正确以外，有时还需要相应修改代码，例如有的地区是以周一作为星期的开始，有的是以周日作为星期的开始<br>12）配置和兼容性问题<br>配置包括不同的外设，例如键盘布局、打印机等等，保证使用没有问题，如打印机能打印出软件发送的所有字符，在不同规格的纸张上打印出正确的格式。<br>兼容性包括在不同语言的应用程序中交换数据时，是否会进行度量单位的换算、扩展字符的转换等等。</p>
<p>转载：<a href="http://www.51testing.com/html/36/n-841936.html" target="_blank" rel="noopener">http://www.51testing.com/html/36/n-841936.html</a></p>
]]></content>
      <tags>
        <tag>功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux知识点</title>
    <url>/2020/11/18/LinuxKnowledgePoints/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="1-登录和退出系统"><a href="#1-登录和退出系统" class="headerlink" title="1.登录和退出系统"></a>1.登录和退出系统</h2><p>在用户启动Linux系统后，为保证系统的安全性，用户登录系统时，为了使系统能够识别自己，必须输入用户名和密码，经系统验证无误后方能进入系统。<br>通常在Linux有三类用户：<br>root：超级用户帐号类似于Windows2000中的Administrator一样，它对系统的访问和控制没有限制。<br>普通用户：这个帐号供普通用户使用，可以进行有限的操作。<br>进程用户：对进程请求资源的访问进行限制。 </p>
<h2 id="2-关机命令："><a href="#2-关机命令：" class="headerlink" title="2.关机命令："></a>2.关机命令：</h2><p>shutdown 或 shutdown –h now/+n(立即或n分钟后关闭系统)<br>halt：关闭系统（其实就是调用shutdown –h）<br>init 0</p>
<h2 id="3-重新启动命令："><a href="#3-重新启动命令：" class="headerlink" title="3.重新启动命令："></a>3.重新启动命令：</h2><p>shutdown –r<br>init 6<br>reboot </p>
<h2 id="4-常用命令的使用"><a href="#4-常用命令的使用" class="headerlink" title="4.常用命令的使用"></a>4.常用命令的使用</h2><p>获得帮助命令：help、man<br>列出当前路径命令：pwd<br>显示登录计算机的用户信息：who<br>参看最近系统使用者登录的信息：last<br>更换登录者命令：su<br>显示和设定系统的日期和时间命令：date</p>
<h2 id="5-Linux命令格式"><a href="#5-Linux命令格式" class="headerlink" title="5.Linux命令格式"></a>5.Linux命令格式</h2><p>命令提示符标识了命令行的开始，用户可以在提示符后面输入任何命令及参数。<br>$：普通用户登陆时的命令提示符<br>#：root用户登陆时的命令提示符。<br>Linux操作系统对于英文字符的处理是大小写敏感的，无论是文件名还是命令名都需要区分大小写。通常命令以小写方式输入。<br>命令的补全方式：<br>TAB：系统自动补全</p>
<h2 id="6-目录管理命令"><a href="#6-目录管理命令" class="headerlink" title="6.目录管理命令"></a>6.目录管理命令</h2><p>pwd：显示当前工作目录<br>ls：列文件目录,ls [可选项]  [子目录名] [文件名]<br>        不带任何选项(ls)：列出当前目录（root）下的子目录与文件，不包括隐藏文件。<br>        选项-l（ls -l）：列出当前目录（root）下的子目录与文件的详细信息<br>        选项-a（ls -a）：列出当前目录下的子目录与文件，包括那些隐藏文件，其中以“.”开头的文件是隐藏的<br>        使用文件名作为参数（ls -l 文件名），将只显示指定文件的信息<br>        ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>cd：改变当前工作目录,cd  [目录名]<br>        cd /home 进入 ‘/ home’ 目录’<br>        cd .. 返回上一级目录<br>        cd ../.. 返回上两级目录<br>        cd 进入个人的主目录<br>        cd ~user1 进入个人的主目录<br>        cd - 返回上次所在的目录<br>mkdir：建立目录 ,mkdir  [可选项] [目录名]<br>        可创建一个目录或多个目录，多个目录用（空格）隔开 (mkdir t1 t2 t3)<br>        加选项¬-p：递归建立两个以上的目录（创建一个多级目录）mkdir -p t1/ t2<br>rmdir：删除目录 ,rmdir  [可选项] [目录名]<br>        注意：要删除的目录必须是空目录<br>        可删除一个目录或多个目录，多个目录用（空格）隔开 (rmdir t1 t2 t3)<br>        加选项¬-p：递归删除  rmdir -p t1/ t2</p>
<h2 id="7-文件管理命令"><a href="#7-文件管理命令" class="headerlink" title="7.文件管理命令"></a>7.文件管理命令</h2><p>file:查看文件类型，file  [可选项] 文件名<br>touch:新建文件;修改文件时间属性，touch  [可选项] 文件名<br>touch命令中参数指定的文件不存在时，touch命令将按照参数中的文件名字建立文件，该文件为空文件，文件的大小为“0”字节。<br>touch命令通常应用于为满足某些需求（如实验、测试）而建立临时文件的场合。<br>cp:复制文件，cp  [选项] 源文件或目录 目标文件或目录<br>cp file1 file2：将当前目录中的file1文件复制为file2文件<br>cp file1 file2 lxq：将当前目录中的filel和file2两个文件复制到当前目录的子目录lxq中<br>cp -r a/ b/：选项- r或-R， cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。<br>rm:删除文件，rm  [选项] 文件或目录<br>rm f<em>：可以同时删除参数中指定的多个文件（f开头的文件）。<br>rm -r 目录：rm命令与“-r”选项配合使用可以完整地删除整个目录，无需事先删除目录中的内容。如果没有使用-r选项，则rm不会删除目录。<br>mv:文件移动与文件重命名，mv [选项] 源文件或目录 目标文件或目录<br>find:查找文件，find  [起始目录] [查找条件] [操作]<br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name \</em>.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 </p>
<h2 id="8-Linux文件查看"><a href="#8-Linux文件查看" class="headerlink" title="8.Linux文件查看"></a>8.Linux文件查看</h2><p>文本文件查看命令<br>cat、more、less、head和tail<br>cat 和more的区别<br>相同点在于：都是用来查看文件内容的指令，两者用法基本相同<br>不同点在于：cat指令查看完毕后会自动返回到正常模式而more指令则需要用户手动退出查看模式<br>head和tail的区别<br>head命令用于显示文件的头部，不使用任何选项时，默认显示文件的最前10行内容。<br>tail命令用于显示文件的尾部，不使用任何选项时，默认显示文件的最后10行内容。<br>通过在head和tail命令中使用选项“-n”，可以设置显示文件的前n行或后n行。<br>通配符：<br>？：代表任意的一个单字符<br><em>：代表任意个字符（0、1或多个）<br>[…]：代表“…”指定的字符范围<br>文本处理：<br>    grep str /tmp/test            在文件 ‘/tmp/test’ 中查找 “str”<br>    # grep ^str /tmp/test           在文件 ‘/tmp/test’ 中查找以 “str” 开始的行<br>    # grep [0-9] /tmp/test         查找 ‘/tmp/test’ 文件中所有包含数字的行<br>    # grep str -r /tmp/</em>             在目录 ‘/tmp’ 及其子目录中查找 “str”<br>    # diff file1 file2                   找出两个文件的不同处<br>    # sdiff file1 file2                 以对比的方式显示两个文件的不同</p>
<h2 id="9-Linux文本编辑器vi"><a href="#9-Linux文本编辑器vi" class="headerlink" title="9.Linux文本编辑器vi"></a>9.Linux文本编辑器vi</h2><p>文本输入：<br>要输入文本必须首先将工作模式转换为文本编辑模式，<br>在命令模式下键入i、I、a、A、o、O等命令中的任意一个<br>即可。此时在状态/命令区出现“–INSERT–”。<br>•    i   从当前的光标位置开始输入字符<br>•    I   光标移动到当前行的行首，开始输入字符<br>•    a   从当前光标的下一个位置，开始输入字符<br>•    A   光标移动到当前行的行尾，开始输入字符<br>•    o   在光标所在行之下新增一行<br>•    O   在光标所在行之上新增一行<br>•    r     替换当前字符<br>•    R     替换当前字符及其后的字符，直至按ESC键<br>•    s      从当前光标位置处开始，以输入的文本替代指定数目的字符<br>•    S      删除指定数目的行，并以所输入文本代替之<br>•    ncw或nCW     修改指定数目的字<br>•    n1，n2 co n3 将n1行到n2行之间的内容拷贝到第n3行下<br>•    n1，n2 m n3  将n1行到n2行之间的内容移至到第n3行下<br>•    n1，n2 d     将n1行到n2行之间的内容删除<br>打开文件<br>文件的打开与读取操作<br>•    :vi filename<br>    打开或新建文件名为的文件到vi 编辑器中,并将光标置于第一行首<br>•    :vi +n filename<br>    打开文件，并将光标置于第n行首<br>•    :vi + filename<br>    打开文件，并将光标置于最后一行首<br>•    :vi +/pattern filename<br>    打开文件，并将光标置于第一个与pattern匹配的串处<br>•    :vi filename….filename<br>    打开多个文件，依次进行编辑<br>•    :w<br>    将工作缓冲区的变化写入默认文件中<br>•    :w filename<br>    将工作缓冲区的变化写入名为的文件中<br>•    :e filename<br>    打开文件filename进行编辑<br>•    :r filename<br>    读取文件内容到当前vi 编辑器中<br>Vi指令模式下常用命令<br>    :w       将编辑的文本存盘。<br>    :w!      若文件属性为“只读”时，强制存盘。<br>    :q      退出 vi（进入后没编辑过，q退出）。<br>    :q!      退出且不存盘（进入后编辑过不存盘，q！退出）。<br>    :wq      存盘并退出<br>命令行模式命令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>移动光标到行首，等价[Home]</td>
<td>dd</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>$</td>
<td>移动光标到行尾，等价[End]</td>
<td>dnd</td>
<td>从光标当前开始删n行</td>
</tr>
<tr>
<td>PageDown</td>
<td>向下一页</td>
<td>yy</td>
<td>复制一行</td>
</tr>
<tr>
<td>PageUp</td>
<td>向上一页</td>
<td>P</td>
<td>粘贴复制的文字</td>
</tr>
<tr>
<td>d+方向键</td>
<td>删除文字</td>
<td>/string</td>
<td>从当前光标开始，向下查找指定的字符串</td>
</tr>
<tr>
<td>x</td>
<td>删除光标处的字符</td>
<td>?string</td>
<td>从当前光标开始，向上查找指定的字符串</td>
</tr>
</tbody></table>
<h2 id="10-用户账号文件、群组文件"><a href="#10-用户账号文件、群组文件" class="headerlink" title="10.用户账号文件、群组文件"></a>10.用户账号文件、群组文件</h2><p>10.1用户账号文件<br>    /etc/passwd：保存用户账号除了口令的其他信息，系统中的所有用户都可以读取其内容。不安全。<br>    例子：<br>    head -3  /etc/passwd—前3行信息，第一行是root超级管理员帐户<br>    tail -3  /etc/passwd—后三行信息，新建用户帐户添加在文件末尾<br>    “/etc/passwd”文件的每一行定义一个用户的属性。每个用户的属性包括七个部分，各部分以“：”分割，格式如下：用户账号的名称：口令（加密）：用户编号(uid )：用户组编号（gid )：用户全名：用户宿主目录：用户选用的命令解释器（Shell）<br>10.2用户口令文件<br>    /etc/shadow：保存加密的用户口令，只有管理员用户root才可以读取其中的内容。<br>    “/etc/shadow”文件的每一行定义一个用户的口令属性。每个口令的属性包括9个部分，各部分以“：”分割，格式如下：用户名：口令：最后一次修改时间：最大时间间隔：最小时间间隔：警告时间：不活动时间：失效时间：标志（未使用）<br>10.3组账号文件<br>    /etc/group：保存用户组除了口令的其他信息，系统中的所有用户都可以读取其内容。<br>    “/etc/group”文件的每一行定义一个组的属性。每个组的属性包括四个部分，各部分以“：”分割，格式如下：组名：组口令（加密）：组ID(gid )：组内用户列表<br>10.4组口令文件<br>    /etc/gshadow：用于定义用户组口令、组管理员等信息，只有管理员用户root才可以读取其中的内容。<br>    “/etc/gshadow”文件的每一行定义一个组的口令属性。每个口令的属性包括4个部分，各部分以“：”分割，格式如下：用户组名称：用户组口令：组的管理员帐号：属于该组的用户成员列表</p>
<h2 id="11-用户帐号维护命令"><a href="#11-用户帐号维护命令" class="headerlink" title="11.用户帐号维护命令"></a>11.用户帐号维护命令</h2><p>useradd<br>1,添加用户帐号<br>    useradd 用户名：添加后需使用passwd命令设置口令才能登录<br>2,添加用户帐号时指定用户私有组<br>    useradd –g 组名 用户名<br>usermod<br>1,改变用户帐号名<br>    usermod –l 新用户登录名 当前用户登录名<br>2,锁定用户帐号<br>    usermod –L 用户帐号名：使其不能登录系统<br>3,解锁用户帐号<br>    usermod –U 用户帐号名<br>groupadd<br>1,建立普通组帐号名<br>    groupadd 组账号名<br>2,建立系统组账号<br>    groupadd –r 系统组账号名<br>groupmod<br>1,改变组帐号GID<br>    groupmod –g 新的GID名 用户组账号名<br>2,改变组帐号名<br>    groupmod –n 新的组名 原用户组名<br>groupdel<br>groupdel 组账号名称：删除指定的组账号<br>passwd<br>1,设置指定用户口令<br>    passwd  用户账号名<br>2,查询用户口令状态(只有root能用)<br>    passwd –S 用户账号名<br>3,锁定帐号<br>    passwd -l 用户账号名(只有root能用)<br>4,解锁用户帐号(只有root能用)<br>    passwd –u 用户账号名<br>5,删除用户口令<br>    passwd –d 用户帐号名</p>
<h2 id="12-权限管理"><a href="#12-权限管理" class="headerlink" title="12.权限管理"></a>12.权限管理</h2><p>12.1文件<br>读(r)：允许读文件的内容<br>写(w)：允许向文件中写入数据<br>执行(x)：允许将文件作为程序执行<br>12.2目录<br>读(r)：允许查看目录中有哪些文件和目录<br>写(w)：允许在目录下创建(或删除)文件、目录<br>执行(x)：允许访问目录(用cd命令进入该目录，并查看目录中可读文件的目录)<br>12.3用户分类<br>文件所有者(owner)：建立文件、目录的用户<br>同组用户(group)：属于同一组群的用户，对属于该组群的文件有相同的访问权限<br>其它用户(other)：除了文件所有者、同组用户之外的其它用户<br>12.4表示方式<br>字母表示：每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。<br>数字表示法:</p>
<table>
<thead>
<tr>
<th>字母表示形式</th>
<th>十进制表示形式</th>
<th>权限含义</th>
<th>字母表示形式</th>
<th>十进制表示形式</th>
<th>权限含义</th>
</tr>
</thead>
<tbody><tr>
<td>- - -</td>
<td>0</td>
<td>无权限</td>
<td>r - -</td>
<td>4</td>
<td>可读</td>
</tr>
<tr>
<td>- - x</td>
<td>1</td>
<td>可执行</td>
<td>r - x</td>
<td>5</td>
<td>可读、执行</td>
</tr>
<tr>
<td>- w -</td>
<td>2</td>
<td>可写</td>
<td>r w -</td>
<td>6</td>
<td>可读、写</td>
</tr>
<tr>
<td>- w x</td>
<td>3</td>
<td>可写、执行</td>
<td>r w x</td>
<td>7</td>
<td>可读、写、执行</td>
</tr>
</tbody></table>
<p>12.5设置文件目录权限方法<br>chmod  [可选项] [权限]  目录或文件名<br>1、文字设定法<br>chmod [who] [+ | - | =] [mode]  [文件名| 目录名]<br>2、数字设定法<br>chmod  [mode] 文件名<br>注意1：</p>
<ul>
<li>添加某个权限。 </li>
</ul>
<ul>
<li>取消某个权限。<br>= 赋予给定权限并取消其他所有权限（如果有的话）。<br>注意2：<br>0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加，其值的范围是0-7，用来表示一组“rwx”权限。因为有三个组，所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。<br>注意3：<br>u 表示“用户（user）”，即文件或目录的所有者。<br>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。<br>o 表示“其他（others）用户”。<br>a 表示“所有（all）用户”。它是系统默认值。<br>注意4：<br>r 可读。<br>w 可写。<br>x 可执行，只有目标文件对某些用户是可执行时才追加x 属性。<br>设置文件目录权限例子<br>$chmod g+r,o+r example<br>$ chmod a+x sort<br>$ chmod ug+w,o-x text<br>$ chmod  ugo–x  mm.txt<br>$ chmod  644  mm.txt<br>步骤：更改文件权限和所有者<br>#更改chen为登陆用户<br>[root@localhost root]#su chen<br>#以chen的身份创建文件chentest<br>[chen@localhost chen]$cat chentest<br> 陈的文件<br> &lt;ctrl+D&gt;<br>#修改文件权限为chen及其所在组成员可读可写可执行，其他组成员只读<br>[chen@localhost root]$chmod 774 chentest<br>#Root用户将文件file.txt的属主修改为chen，属组修改为netadmin<br>[root@localhost root]#chown chen.netadmin file.txt</li>
</ul>
<p>12.6更改属主和组<br>1、chown<br>chown [-R] &lt;用户[:组]&gt;&lt;文件或目录&gt;<br>-R:表示对目录及其子目录进行递归设置<br>将文件file1的属主改成user1<br>chown user1 file1<br>将文件file2的组改成user1<br>chown :user1 file2<br>将文件file3的属主和组都改成user1<br>chown user1:user1 file3<br>将mydir目录及其子目录下所有文件和目录的属主和组改成user1<br>chown –R user1:user1 mydir<br>2、umask<br>设置文件或目录的默认权限<br>将默认权限改为拥有者读、写、执行，同组用户读、执行，其它用户读。<br>umask u=rwx,g=rx,o=r<br>umask 023<br>3、chgrp<br>chgrp group file<br>改变文件或目录组群<br>文件data2的组别改为staff<br>chgrp staff data2</p>
<h2 id="13-磁盘分区"><a href="#13-磁盘分区" class="headerlink" title="13.磁盘分区"></a>13.磁盘分区</h2><p>IDE接口的硬盘采用“hdxN”的文件名格式表示，其中“x”是英文字母，指分区所在的硬盘，第一块硬盘用“a”表示，第二块用“b”表示，依次类推；“N”是数字，1~4表示主分区，5开始之后的数字表示逻辑分区。<br>SCSI接口的硬盘代号由sda开始算起。目前常见的USB接口的优盘或者USB外接式硬盘，在Linux下仿真成SCSI设备，代号也是从sda开始算起。</p>
<h2 id="14-Linux文件系统"><a href="#14-Linux文件系统" class="headerlink" title="14.Linux文件系统"></a>14.Linux文件系统</h2><p>14.1Linux文件系统类型<br>EXT2：正在被逐渐淘汰<br>EXT3：在EXT2文件系统的基础上添加了“日志”功能<br>Swap：在Linux系统的交换分区中使用<br>注：对于微软公司的文件系统格式FAT32和NTFS，Linux能够部分地进行支持，大多数Linux系统支持FAT32文件系统的读写和NTFS的只读，而不能支持NTFS文件系统的写入。<br>14.2虚拟文件系统VFS<br>Linux可以支持多种不同的文件系统，并给Linux的其它部分和用户提供统一的文件操作接口，虚拟文件系统（VFS, Virtual File System）是实现这一功能的关键。通过虚拟文件系统，人们可以方便地向Linux增加新的文件系统。<br>VFS实际上是用户进程与实际文件系统之间的一种接口。虚拟文件系统隐藏了各种硬件的具体细节，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。<br>vfat:在linux中把DOS下所有FAT文件系统统称为vfat。<br>NFS:即网络文件系统，用于在unix系统间通过网络进行文件共享，用户可以把网络中NFS服务器提供的共享目录挂载到本地文件目录中，可以象对本地文件系统一样操作NFS文件系统中的内容。</p>
<h2 id="15-Linux文件系统加载"><a href="#15-Linux文件系统加载" class="headerlink" title="15.Linux文件系统加载"></a>15.Linux文件系统加载</h2><p>mount  [-t vfstype]  [-o optoins]  device  dir<br>1、-t 文件系统类型<br>Fat32为vfat；<br>fat16为msdos<br>CDROM为iso9660<br>Linux分区为ext2或ext3<br>ntfs为NTFS<br>auto自动检测文件系统<br>swap交换分区文件系统<br>2、-o 选项<br>ro以只读方式挂载<br>rw以读写方式挂载<br>codepage=xxx代码页，对于中文codepage=936；iocharset=xxx字符集，对于中文iocharset=gb2312或iocharset=cp936<br>loop    挂载ISO光盘镜像文件<br>3、device 要挂载的设备文件，在/dev目录下<br>4、dir 要挂载的路径<br>umount卸载<br>umount  [选项] [挂载点] [设备名]<br>    用于卸载系统中不需要使用的文件系统<br>任务实施：<br>步骤1：查看磁盘分区。<br>[root@localhost root]# fdisk -l<br>步骤2：创建挂载点<br>[root@localhost root]#mkdir /mnt/usb<br>步骤3：加载U盘<br>[root@localhost root]#mount –t msdos /dev/sdb1 /mnt/usb<br>步骤4：访问<br>[root@localhost root]#ls -l /mnt/usb<br>步骤5：查看磁盘空间<br>[root@localhost usb]#du -s<br>[root@localhost root]#df<br>步骤6：卸载<br>[root@localhost root]#umount /mnt/usb<br>补充-虚拟机添加一块硬盘<br>VM中添加一块SCSI硬盘，加载到目录/newfs中<br>(1)查看添加的盘名：#fdisk –l<br>(2)建立分区并格式化ext3文件系统<br>#fdisk /dev/设备名<br>#mkfs –t ext4 /dev/设备名<br>(3)建立挂载点: #mkdir /newfs<br>(4)加载: #mount /dev/设备名 /newfs</p>
<h2 id="16-磁盘配额管理"><a href="#16-磁盘配额管理" class="headerlink" title="16.磁盘配额管理"></a>16.磁盘配额管理</h2><p>16.1系统管理员用来监控和限制用户或组对磁盘的使用工具。保证所有用户都拥有自己独立的文件系统空间，确保用户使用系统的公平性和安全性<br>16.2两方面限制<br>限制用户和组可以拥有的inode数(文件数)<br>限制分配给用户或组的磁盘块数目(以千字节为单位)<br>16.3三个概念<br>硬限制：超过此设定值后不能继续存储新文件<br>软限制：超过此设定值仍可继续存储，但系统发出警告信息，建议清理以释放更多空间<br>时限：超过软限制多长时间之内可继续存储文件<br>16.4磁盘配额步骤<br>编辑/etc/fstab启用quota功能<br>    (1)备份fstab：#cp /etc/fstab /etc/fstab.backup<br>    (2)在相应分区上修改挂载参数，在option上添加usrquota或grpquota：#vi /etc/fstab<br>    (3)重新挂载文件系统或重启：#mount -a<br>在设置限额的文件系统上创建quota文件，重新生成磁盘用量表<br>    #quotacheck -avug<br>分配用户和组的quota<br>    (1)设置用户的配额：#edquota –u username<br>    (2)将相同的配额设置复制给其他用户：#edquota –p&lt;参考用户&gt;&lt;待设置用户&gt;<br>    (3)设置组的配额：#edquota –g groupname<br>    (4)设置软限制的宽限期：#edquota -t<br>启动配额设置<br>    (1)重启系统<br>    (2)执行命令：#quotaon -avug<br>查看磁盘配额<br>    (1)查看指定用户的quota设置：#quota [-ugv] [&lt;用户名&gt;]<br>    (2)查看当前用户的quota设置：#quota [-ugv]<br>    (3)查看所有用户的quota设置：#repquota [-augv]</p>
<h2 id="17-文件压缩解压缩"><a href="#17-文件压缩解压缩" class="headerlink" title="17.文件压缩解压缩"></a>17.文件压缩解压缩</h2><p>17.1文件压缩可以减少文件的大小，这有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。<br>17.2Linux常用文件压缩解压缩命令<br>zip/unzip<br>gzip/gunzip<br>具体分析：<br>zip  [选项] 文件名：打包和压缩文件<br>•    -d：从压缩文件中抽走并删除<br>•    -g：增加而不重新压缩<br>•    -u：更新<br>•    -r：按目录结构递归压缩目录中所有文件<br>•    -m：压缩完成后删除源文件<br>unzip  [选项] 文件名 ：用于解压缩扩展名为.zip的压缩文件<br>•    1.-v：查看压缩文件目录，但不解压<br>•    2.-d：把压缩文件解压到指定目录下<br>•    3.-n：不覆盖已经存在的文件<br>gzip  [选项] 文件名：将文件压缩为后缀为.gz的压缩文件<br>•    -d：对压缩文件解压<br>•    -l：对每个压缩文件显示详细信息，包括压缩文件的大小、未压缩文件的大小、压缩比、未压缩文件的名字<br>•    -r：参数为目录时，按目录结构递归地压缩目录中的所有文件<br>•    -v：对每个压缩和解压的文件显示文件名和压缩比<br>gunzip  [选项] 文件名：把gzip命令压缩的.gz文件进行解压缩<br>•    1.-v：显示解压缩文件的冗长结果<br>•    2.-r：递归处理，将指定目录下的所有文件及子目录一并处理<br>17.3Linux文件打包命令<br>tar<br>tar [选项] [打包文件名] [文件|目录]<br>•    -c：创建tar包<br>•    -f：指定tar包的文件名<br>•    -v：显示处理文件信息的进度<br>•    -x：从备份文件中释放出来<br>•    -t：列出备份文件的内容<br>•    -z：用gzip命令来压缩/解压缩文件<br>•    -j：调用bzip2命令来压缩/解压缩文件<br>•    -r：向归档/压缩文件追加文件和目录<br>•    -u：更新文件</p>
<h2 id="18-安装、升级、删除、查询RPM包"><a href="#18-安装、升级、删除、查询RPM包" class="headerlink" title="18.安装、升级、删除、查询RPM包"></a>18.安装、升级、删除、查询RPM包</h2><p>rpm  选项  RPM包的文件名<br>1，查询<br>rpm –qa：查询系统中安装的所有RPM软件包<br>rpm –q 软件包名称：查询指定软件包是否安装<br>rpm –qi 软件包名称：查询系统中已安装软件包的描述信息<br>rpm –ql 软件包名称：查询系统中已安装软件包包含的文件列表<br>rpm –qf 文件全路径名：查询指定文件所属的软件包<br>2，安装<br>rpm –i RPM包全路径文件名：安装指定的RPM包到当前系统<br>rpm –ivh RPM包全路径文件名：安装并显示进度信息<br>注意：<br>i表示install<br>v表示verbose，显示较为详细信息<br>h表示hash，显示“#”表示安装进度<br>3，删除<br>rpm –e RPM包名称：从当前系统中删除已安装的软件包<br>4，升级<br>rpm –U RPM软件包全路径名：使用指定的PRM软件包对当前系统统一软件的较低级别版本进行升级</p>
<h2 id="19-磁盘的加密测试步骤"><a href="#19-磁盘的加密测试步骤" class="headerlink" title="19.磁盘的加密测试步骤"></a>19.磁盘的加密测试步骤</h2><p>安装软件包    yum install  cryptsetup<br>查是否安装软件包 yum list all |grep cryptsetup<br>建立分区   fdisk  /dev/sdb<br>格式化分区并设置密码 cryptsetup luksFormat  /dev/sdb8（大写YES）<br>启用加密分区<br>cryptsetup luksOpen  /dev/sdb8  testfs<br>创建文件系统<br>mkfs -t ext4 /dev/mapper/testfs<br>挂载文件系统mkdir /testfs mount  /dev/sdb8 /testfs<br>卸载锁定加密盘<br>umount /testfs cryptsetup luksClose   testfs<br>验证是否可以再次挂载 mount  /dev/sdb8 /testfs</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Loadrunning的web_custom_request函数</title>
    <url>/2020/08/01/LoadrunningJson/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="问题：loadrunning怎么请求json参数："><a href="#问题：loadrunning怎么请求json参数：" class="headerlink" title="问题：loadrunning怎么请求json参数："></a>问题：loadrunning怎么请求json参数：</h2><p>request payload<br>{“pageNo”:1,”perPageSize”:10,”type”:”c”,”companyId”:”CF9111CB233F46C290F662E0FAFA3F25”,”year”:2020}<br>应该怎么请求？<br>用web_submit_data()函数，在回放脚本时，发现返回的数据总数返回上一接口的返回数据。<br><img src= "/img/loading.gif" data-src="/images/LoadrunningJson1.png" alt="问题"></p>
<h2 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h2><h3 id="1、什么是request-payload"><a href="#1、什么是request-payload" class="headerlink" title="1、什么是request payload"></a>1、什么是request payload</h3><p>Request Payload更准确的说是http request的payload body。一般用在数据通过POST请求或者PUT请求。它是HTTP请求中空行的后面那部分。（PS:这里涉及一个http常被问到的问题，http请求由哪几部分组成，一般是请求行，请求头，空行，请求体。payload body应该是对应请求体。）<br>这种请求 Content-Type 为 application/json，浏览器会认为这是复杂请求，先执行一次 OPTIONS 请求判断是否合法，如果服务器没有给出正确的回应，浏览器会在控制台报错：跨域请求。<br>具体可进入链接了解：<a href="https://segmentfault.com/a/1190000018774494" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018774494</a></p>
<h3 id="2、web-custom-request函数介绍"><a href="#2、web-custom-request函数介绍" class="headerlink" title="2、web_custom_request函数介绍"></a>2、web_custom_request函数介绍</h3><p>LoadRunner提供的web_custom_request函数可以用于实现参数的动态生成。在LoadRunner中，web_reg_save_param和custom_request都常于处理参数的动态生成。<br>web_reg_save_param函数是大家都已经熟悉的了，它的主要作用是从一个response中获得后续的request需要使用的数据，然后将其作为一个参数保存下来，供后续步骤使用。该方法在LoadRunner中被称为Correlation（关联）。<br>而web_custom_request函数则可以用于完全自定义向服务端发送的request。<br>web_custom_request方法的原型是：<br>int web_custom_request (const char *RequestName, <List of Attributes>,[EXTRARES, <List of Resource Attributes>,] LAST );<br>其中List of Attributes的主要项目是Method，URL和BODY等。</p>
<h3 id="3、LoadRunner中web-custom-request-和-web-submit-data的差别"><a href="#3、LoadRunner中web-custom-request-和-web-submit-data的差别" class="headerlink" title="3、LoadRunner中web_custom_request 和 web_submit_data的差别"></a>3、LoadRunner中web_custom_request 和 web_submit_data的差别</h3><p>(1)实现的功能不同<br>web_submit_data只能发送POST类型的请求。<br>web_custom_request方法可以发送POST和GET类型的请求。<br>(2)请求数据提交方式不同<br>web_submit_data以”Name=属性名称,”,”Value=属性值” 方式提交数据。<br>web_custom_request以”Body=属性名称=属性值&amp;属性名称=属性值”方式提交数据。<br>(3)上下文依赖不同<br>web_submit_data不依赖上下文，不管是否打开模块的链接页面，就直接向服务器发送post请求。<br>web_custom_request：会依赖上下文，即如果前面的页面打开失败或没有打开，则该操作就会失败，如：登陆一个论坛成功后，点击某个板块，然后发帖(写入帖子题目和内容，提交，相当于向服务器发送了一个post请求)，如果点击某个模块后打开链接页面失败，则web_custom_request就会失败，即依赖于板块的链接页面是否成功打开，如果没有打开，就不能进行后面的发帖了。</p>
<h3 id="4、为什么选择web-custom-request函数自定义请求"><a href="#4、为什么选择web-custom-request函数自定义请求" class="headerlink" title="4、为什么选择web_custom_request函数自定义请求"></a>4、为什么选择web_custom_request函数自定义请求</h3><p>web_custom_request函数自定义请求，所有web_submit_data方法发送的请求都可以使用web_custom_request来实现，web_custom_request可以实现web_submit_data无法实现的请求。<br>如：<br>“Name=pageNo”, “Value=1”, ENDITEM,<br>“Name=pdVersionId”, “Value=&quot;2001&quot;“, ENDITEM,<br>“Name=perPageSize”, “Value=30”, ENDITEM,<br>“Name=projectType”, “Value=&quot;3&quot;“, ENDITEM,<br>“Name=year”, “Value=&quot;2020&quot;“, ENDITEM,<br>如果我们想提交的某个属性包含包含多个值，它就无法处理了，只能通过多个web_submit_data来处理。</p>
<h3 id="5、了解web-custom-request的参数"><a href="#5、了解web-custom-request的参数" class="headerlink" title="5、了解web_custom_request的参数"></a>5、了解web_custom_request的参数</h3><p>URL -  统一资源定位器，通常为请求链接地址<br>Method -  请求方法：POST、GET<br>TargetFrame -  包含当前链接或资源的frame的名称<br>EncType -  提交请求使用的编码类型(type of encoding)。EncType指定“Content-Type”请求头的值，比如“text/html”。web_custom_request不处理未编码的请求体。Body参数指定的请求体会使用指定的编码。<br>RecContentType -  指定了Content–Type  响应头的类型，比如text/html,application/x-javascript。当没有设置Resource属性时，用它来确定目标URL是否是可录制的资源。<br>Refer -  指定引用的页面<br>Body -  请求体<br>Mode - 录制级别：HTML、HTTP<br>可通过下方链接了解，这里就不具体描述，只描述我用到的。<br><a href="https://blog.csdn.net/huilan_same/article/details/51603855?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/huilan_same/article/details/51603855?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
<h3 id="6、解决代码"><a href="#6、解决代码" class="headerlink" title="6、解决代码"></a>6、解决代码</h3><p>代码如下：<br>web_custom_request(“getProjectList”,<br>“URL=<a href="http://19.111.49.70/cacz/project/businessexpenditure/specialproject/specialprojectlist/getProjectList&quot;" target="_blank" rel="noopener">http://19.111.49.70/cacz/project/businessexpenditure/specialproject/specialprojectlist/getProjectList&quot;</a>,<br>“Method=POST”,<br>“RecContentType=application/json”,<br>“EncType=application/json”,<br>“Mode=HTML”,<br>“Body={&quot;pageNo&quot;:1,&quot;perPageSize&quot;:10,&quot;type&quot;:&quot;c&quot;,&quot;companyId&quot;:&quot;CF9111CB233F46C290F662E0FAFA3F25&quot;,&quot;year&quot;:2020},<br>LAST);</p>
]]></content>
      <tags>
        <tag>Loadrunning</tag>
      </tags>
  </entry>
  <entry>
    <title>易用性测试详解</title>
    <url>/2020/11/18/DetailedExplanationOfUsabilityTest/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="易用性测试定义"><a href="#易用性测试定义" class="headerlink" title="易用性测试定义"></a>易用性测试定义</h2><p>易用性测试是指用户使用软件时是否感觉方便，比如是否最多点击鼠标三次就可以达到用户的目的。易用性和可用性存在一定的区别，可用性是指是否可以使用，而易用性是指是否方便使用。</p>
<h2 id="易用性测试的内容"><a href="#易用性测试的内容" class="headerlink" title="易用性测试的内容"></a>易用性测试的内容</h2><p>易用性测试包括针对应用程序的测试，同时还包括对用户手册系统文档的测试。通常采用质量外部模型来评价易用性。包括如下方面的测试: (1)易理解性;(2)易学习性;(3)易操作性(4)吸引性;(5)依从性。<br>易用性可有以下方面：导航，图形，内容，整体界面</p>
<h2 id="易用性测试遵循原则"><a href="#易用性测试遵循原则" class="headerlink" title="易用性测试遵循原则"></a>易用性测试遵循原则</h2><p>对于易用性测试可遵循以下原则：<br>1、完成相同或相近功能的按钮用Frame 框起来，常用按钮要支持快捷方式。<br>2、完成同一功能或任务的元素放在集中位置，减少鼠标移动的距离。<br>3、按功能将界面划分局域块，用Frame 框起来，并要有功能说明或标题。<br>4、界面要支持键盘自动浏览按钮功能，即按Tab 键的自动切换功能。<br>5、界面上首先应输入的信息和重要信息的控件在Tab 顺序中应当靠前，位置也应放在窗口上较醒目的位置。<br>6、同一界面上的控件数最好不要超过10 个，多于10 个时可以考虑使用分页界面显示。<br>7、分页界面要支持在页面间的快捷切换，常用组合快捷键Ctrl+Tab<br>8、默认按钮要支持Enter 操作，即按Enter 后自动执行默认按钮对应操作。<br>9、可输入控件检测到非法输入后应给出说明信息并能自动获得焦点。<br>10、Tab 键的顺序与控件排列顺序要一直，目前流行总体从上到下，同时行间从左到右的方式。<br>11、复选框和选项框按选择几率的高底而先后排列。<br>12、复选框和选项框要有默认选项，并支持Tab 选择。<br>13、选项数相同时多用选项框而不用下拉列表框。<br>14、界面空间较小时使用下拉框而不用选项框。<br>15、选项数较少时使用选项框，相反使用下拉列表框。<br>16、专业性强的软件要使用相关的专业术语，通用性界面则提倡使用通用性词眼。<br>17、对于界面输入重复性高的情况，该界面应全面支持键盘操作，即在不使用鼠标的情况下采用键盘进行操作。</p>
<h2 id="易用性测试小练习"><a href="#易用性测试小练习" class="headerlink" title="易用性测试小练习"></a>易用性测试小练习</h2><p>下列哪一项不属于软件功能易用性测试关注内容（）<br>A 软件界面的色彩是否协调<br>B 软件是否能主动禁止用户可能进行的非法操作<br>C 软件是否允许用户针对自己的使用习惯进行定制<br>D 软件是否能帮助用户减少输入中的重复劳动<br>答案：A<br>解析：功能易用性是指用户能否方便、快速、准确地使用软件提供的功能来完成需要完成的内容，其主要内容有：1业务符合度；2 功能定制性；3功能的关联度；4数据的共享度；5用户约束的合理性；6 反馈的及时性；其中功能定制性中说明一个软件通常是为不同的用户提供服务，各用户经常使用的业务功能也不尽相同，功能易用性要求软件在一定程度上允许用户针对自己的需求进行定制，这与C选项一致；数据的共享度的一个主要优点就是减少重复输入，从而保证数据一致性，测试时就是检查各个功能的输入，确定是否有重复输入，这与选项D一致；用户约束的合理性中指明软件需要对用户进行约束，选项B属于权限性的约束。<br>转载：<a href="http://www.51testing.com/html/10/n-3722110.html" target="_blank" rel="noopener">http://www.51testing.com/html/10/n-3722110.html</a></p>
]]></content>
      <tags>
        <tag>功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter入门基础</title>
    <url>/2020/08/17/JMeterBasics/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="一、jmeter介绍"><a href="#一、jmeter介绍" class="headerlink" title="一、jmeter介绍"></a>一、jmeter介绍</h2><p>1、 什么是jmeter<br>Apache JMeter是Apache组织开发的基于Java的压力测试工具。<br>2、 Jmeter可以做什么<br>(1) 接口测试—-基础<br>(2) 性能测试<br>(3) 压力测试<br>(4) 数据库测试<br>(5) Java程序测试<br>3、 Jmeter优缺点<br>优点：<br>(1) 开源免费<br>(2) 支持多协议<br>(3) 轻量级<br>(4) 功能强大<br>缺点：<br>使用jmeter无法验证js程序，也无法验证页面UI，所以要需要和selenium配合来完成web2.0应用测试</p>
<h2 id="二、jmeter安装"><a href="#二、jmeter安装" class="headerlink" title="二、jmeter安装"></a>二、jmeter安装</h2><p>1、JMeter的下载与配置<br>下载地址：<a href="http://jmeter.apache.org/" target="_blank" rel="noopener">http://jmeter.apache.org/</a><br>按照下图进行下载<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics1.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/JMeterBasics2.png" alt="img"><br>下载完成后，解压，目录结构如下<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics3.png" alt="img"><br>修改中文：进入bin目录，找到JMeter.bat文件，右键编辑文件，并修改如信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> JMETER_LANGUAGE=-Duser.language=<span class="string">"**zh**"</span> -Duser.region=<span class="string">"**CN**"</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/JMeterBasics4.png" alt="img"><br>到这保存退出就可以通过JMeter.bat运行JMeter了，但因为后续的测试可能会使用到一些拓展的插件，所以还需要导入jmeter-plugins-manager。<br>2、plugins-manager下载与安装<br>jmeter-plugins-manager下载地址：<a href="https://jmeter-plugins.org/install/Install/" target="_blank" rel="noopener">https://jmeter-plugins.org/install/Install/</a><br><img src= "/img/loading.gif" data-src="/images/JMeterBasics5.png" alt="img"><br>下载完成后将jar包放入lib/ext<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics6.png" alt="img"><br>完成后即可启动jmeter<br>3、Jmeter启动与插件安装<br>执行jmeter.bat文件，弹出的控制台不可关闭。启动后如下：<br>注意：在linux系统需执行jmeter.sh文件<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics7.png" alt="img"><br>点击选项-&gt;plugins manager<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics8.png" alt="img"><br>Installed Plugins 为已安装的插件，Available Plugins 为可安装的插件 ，Upgrades为可更新的插件<br>勾选插件后，点击右下角的Apply Changes and Restart JMeter，安装后会自动重启JMeter，这里推荐安装3 Basic Graphs 和 jpgc - Standard Set<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics9.png" alt="img"><br>4、Badboy的下载<br>下载地址：<a href="http://www.badboy.com.au/" target="_blank" rel="noopener">http://www.badboy.com.au/</a><br>点击Download<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics10.png" alt="img"><br>选择最新版本下载<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics11.png" alt="img"><br>下载，安装<br>5、BadBoy的启动<br>进入安装文件夹，运行badboy.exe即可启动。</p>
<h2 id="三、目录了解"><a href="#三、目录了解" class="headerlink" title="三、目录了解"></a>三、目录了解</h2><p>1、bin目录<br>examples（例子）：该目录下存放Jmeter官方给的请求模板<br>report-template（报告模板）：该目录下存放Jmeter的报告模板（Jmeter是有自己的报告的）<br>templates（模板）：该目录下存放Jmeter的各类配置模板，例如：JDBC、Beanshell、ThinkTime等<br>jmeter.bat：Windows 的启动命令。<br>jmeter.log：日志文件。<br>jmeter.sh：Linux 系统下的启动文件。<br>jmeter.properties：系统配置文件，如配置编码格式。<br>jmeter-server.bat：Windows 分布测试要用到的服务器配置。<br>jmeter-server：Linux 分布式测试要用到的服务器配置。<br>2、docs目录<br>api：前面谈到Jmeter是开源的，此处便是它的API文档。<br>css：xxxx。<br>3、mage目录<br>部分图片资源<br>4、Extras目录<br>存放Build等配置，用于第三方集成构建<br>5、Lib目录<br>存放各类jar包，组件类函数类等<br>6、licenses目录<br>许可证书目录<br>7、printable_docs目录<br>用户手册<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics12.png" alt="img"></p>
<h2 id="四、jmeter入门脚本"><a href="#四、jmeter入门脚本" class="headerlink" title="四、jmeter入门脚本"></a>四、jmeter入门脚本</h2><p>1、添加测试计划—当打开jmeter默认有一个测试计划.<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics13.png" alt="img"><br>2、添加线程组<br>鼠标在测试计划上—右键—添加—线程(用户)—线程组<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics14.png" alt="img"><br>3、添加HTTP请求<br>鼠标在线程组上—右键—添加—取样器—HTTP请求<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics15.png" alt="img"><br>4、配置HTTP请求<br>修改名称:发送百度请求<br>基本信息：<br>（1）填写协议:http<br>（2）填写服务器或IP:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br><img src= "/img/loading.gif" data-src="/images/JMeterBasics16.png" alt="img"><br>5、添加查看结果树<br>鼠标在线程组上—右键—添加—监听器—查看结果树<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics17.png" alt="img"><br>6、运行<br>注意：要保存后才能运行<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics18.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/JMeterBasics19.png" alt="img"><br>7、查看结果<br>可点击text下拉选择请求结果的样式<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics20.png" alt="img"><br>知识点： </p>
<table>
<thead>
<tr>
<th>功能</th>
<th>用例</th>
</tr>
</thead>
<tbody><tr>
<td>测试计划</td>
<td>项目名称</td>
</tr>
<tr>
<td>线程组</td>
<td>业务流程</td>
</tr>
<tr>
<td>HTTP请求</td>
<td>接口请求</td>
</tr>
</tbody></table>
<h2 id="五、线程用户"><a href="#五、线程用户" class="headerlink" title="五、线程用户"></a>五、线程用户</h2><p>线程数:表示请求的虚拟用户数量<br>ramp-up:启动所有线程数所需要的时间(秒)<br>循环次数:线程数循环<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics21.png" alt="img"><br>注意：如果选择循环次数为永远，需要手动停止，会导致最后一个接口请求报错</p>
<h2 id="六、取样器"><a href="#六、取样器" class="headerlink" title="六、取样器"></a>六、取样器</h2><p>作用:向服务器发送请求并且记录响应时间和响应内容</p>
<h2 id="七、jmeter运行原理"><a href="#七、jmeter运行原理" class="headerlink" title="七、jmeter运行原理"></a>七、jmeter运行原理</h2><p>1、jmeter是按照线程的方式来运行的<br>2、jmeterGUl模式运行测试脚本对电脑本身的资源消耗较大，无法实现大的并发和压力测试<br>3、使用命令行模式实现高并发和压力测试<br>4、使用GUl模式主要目的是编写和调面jmeter测试脚本</p>
<h2 id="八、jmeter测试计划要素"><a href="#八、jmeter测试计划要素" class="headerlink" title="八、jmeter测试计划要素"></a>八、jmeter测试计划要素</h2><p>使用jmeter编写测试脚本–要素<br>1、 测试计划<br>2、 在测试计划中至少有一个线程组<br>3、 在线程组中至少有一个取样器<br>4、 在测试计划中必须有监听器</p>
<h2 id="九、jmeter录制脚本"><a href="#九、jmeter录制脚本" class="headerlink" title="九、jmeter录制脚本"></a>九、jmeter录制脚本</h2><p>1、使用badboy录制<br>（1）打开babboy在 地址栏中输入被测网址回车<br>（2）打开badboy时默认记录状态，输入网址直接操作即可<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics22.png" alt="img"><br>（3）操作完成–点击停止记录<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics23.png" alt="img"><br>（4）导出脚本：file–export to jmeter保存<br>2、在jmeter中打开已有文件<br>（1）jmeter脚本文件的后缀名.jmx<br>（2）在jmeter点击打开文件.选择文件路径,找到需要的文件进行打开<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics24.png" alt="img"><br>（3）添加查看结果树（不然看不到运行结果）<br><img src= "/img/loading.gif" data-src="/images/JMeterBasics25.png" alt="img"></p>
<h2 id="十、使用jmeter自身代理录制移动端（了解）"><a href="#十、使用jmeter自身代理录制移动端（了解）" class="headerlink" title="十、使用jmeter自身代理录制移动端（了解）"></a>十、使用jmeter自身代理录制移动端（了解）</h2><p>配置jmeter<br>1.打开jmeter创建新的测试计划<br>2.在测试计划下添加一个线程组<br>3.添加HTTP代理服务器<br>在测试计划下—右键–非测试元—HTTP代理服务<br>4.配置HTTP代理服务器<br>4.1端口号默认<br>4.2 https domains中填写电脑本地IP或localhost<br>查询电脑IP：打开cmd—执行ipconfig<br>4.3目标控制器选择测试计划&gt;线程组<br>4.4点击启动按钮 —点击OK<br>配置手机—打开手机端的 wifi设置<br>设置好了之后启动Jmeter代理服务器的 启动按钮（注意是里面的按钮）<br>然后就可以在手机端去操作业务了，可以正常的录制对应的app应用、微信公众号等业务，在线程组就会抓到对应的的请求<br>录制完成后，停止Jemter上的“HTTP代理服务器”，然后进行脚本调试<br>原理跟web端的脚本录制一样。脚本调试完成之后可以进行后续的压测了</p>
]]></content>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title>Loadrunning脚本运行</title>
    <url>/2020/08/11/LoadrunningScenarioRunning/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="一、启动场景控制台"><a href="#一、启动场景控制台" class="headerlink" title="一、启动场景控制台"></a>一、启动场景控制台</h2><p>1、启动控制台<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning1.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning2.png" alt="img"><br>添加脚本，选择脚本名称，点击“Add==》”按钮，再点击“OK”按钮<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning3.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning4.png" alt="img"></p>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>1、设置generators<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning5.png" alt="img"><br>Name填写为localhost，点击“OK”后，关闭Load Generators窗口<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning6.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning7.png" alt="img"><br>2、配置场景<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning8.png" alt="img"><br>1）选择模式，run mode有两种a、Real-world schedule，b、Basic schedule<br>a、Real-world schedule<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning9.png" alt="img"><br>初始化、启动阶段、运行阶段、停止阶段<br>（1）初始化按默认：a、全部初始化，b、设置单位时间逐步初始化，c、运行前初始化，默认c<br>（2）开始阶段：配置最大用户数，选择方式：同时和增压，默认增压：单位时间增压用户数、单位时间长度<br>（3）运行阶段：选择方式：到运行完成为止 和 持续运行，默认持续运行：配置运行时长<br>（4）停止阶段：选择方式：同时和减压，默认减压：配置单位时间减压用户数、单位时间长度<br>b、Basic schedule<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning10.png" alt="img"><br>初始化、启动阶段、运行阶段、【停止阶段】<br>用户总数：填写/修改“total：[  ]Vusers”的[  ]中数量<br>（1）初始化按默认：a、全部初始化，b、设置单位时间逐步初始化，c、运行前初始化，默认c<br>（2）开始阶段：选择方式：同时和增压，默认同时<br>（3）运行阶段：选择方式：“到运行完成为止”、“持续运行”和“一直运行不停”，默认“到运行完成为止”，选择持续运行则出现停止阶段<br>（4）停止阶段：选择方式：同时和减压<br>3、修改超时时间<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning11.png" alt="img"><br>打开“脚本运行时配置”框，选中“Internet protocol-preferences”，点击“options…”按钮进行配置<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning12.png" alt="img"><br>配置超时时间，http下的“请求连接超时”、“请求接收超时”、“请求存活超时”的时长，及general下的“下载超时”的时长<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning13.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning14.png" alt="img"><br>时长配置好后，点击“OK”再点击“OK”保存配置<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning15.png" alt="img"></p>
<h2 id="三、视图配置及启动"><a href="#三、视图配置及启动" class="headerlink" title="三、视图配置及启动"></a>三、视图配置及启动</h2><p>1、配置运行监控视图<br>切换运行监控界面<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning16.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning17.png" alt="img"><br>配置图表个数，在图表区域点击鼠标右键，选择显示8张图表<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning18.png" alt="img"><br>8张图表<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning19.png" alt="img"><br>修改图表展示所需的图表，选中要修改的图表，双击左侧列表中需要的图表<br>running vusers，tran response time，tran/sec(passed)，total tran/sec(passed)，hits per second，throughput，connections per second，error statistics<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning20.png" alt="img"><br>2、运行场景<br>点击“start scenario”按钮<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning21.png" alt="img"><br>results directory already exists提示框上选择“是”，覆盖目录<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning22.png" alt="img"><br>场景运行中<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning23.png" alt="img"><br>3、运行结果<br>（1）运行时如tran response time，tran/sec(passed)，total tran/sec(passed)， error statistics没有图效果时需检查log看看问题<br>操作，点击右键，选择show vuser log<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning24.png" alt="img"><br>（2）设置run-time setting中log的配置<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning25.png" alt="img"><br>（3）重新运行脚本，可查看show vuser log<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScenarioRunning26.png" alt="img"><br>（4）如果还是没有图，检查一下事务点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在脚本最开始的加上</span></span><br><span class="line">lr_start_transaction();</span><br><span class="line"><span class="comment"># 在末尾加上</span></span><br><span class="line">lr_end_transaction()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Loadrunning</tag>
      </tags>
  </entry>
  <entry>
    <title>Loadrunning容量测试中遇到的问题</title>
    <url>/2020/08/30/CapacityTestingIssues/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="录制完脚本，出错：Failed-to-load-temporary-action-file-C-Users-ADMINI-1-AppData-LocaNTemp-vuac-usr73-restoring-original-file-Check-that-the-TMP-directory-is-not-full-or-write-protected"><a href="#录制完脚本，出错：Failed-to-load-temporary-action-file-C-Users-ADMINI-1-AppData-LocaNTemp-vuac-usr73-restoring-original-file-Check-that-the-TMP-directory-is-not-full-or-write-protected" class="headerlink" title="录制完脚本，出错：Failed to load temporary action file(C\Users\ADMINI~1\AppData\LocaNTemp\vuac usr73),restoring original file.Check that the TMP directory is not full or write protected."></a>录制完脚本，出错：Failed to load temporary action file(C\Users\ADMINI~1\AppData\LocaNTemp\vuac usr73),restoring original file.Check that the TMP directory is not full or write protected.</h2><p>原因：<br>Action.c的文件丢失。<br>解决方法：<br>（1）创建一个新的脚本。<br>（2）在文件夹里找到其他的后缀为.c的文件用工具编辑文本，然后把东西拷出，拷到里新建的脚本里面，补上Action.c的文件的内容，然后重新运行。</p>
<h2 id="大量并发会导致Error-26697-Missing-CR-LF-after-body-trailer-“Transfer-Encoding-chunked”"><a href="#大量并发会导致Error-26697-Missing-CR-LF-after-body-trailer-“Transfer-Encoding-chunked”" class="headerlink" title="大量并发会导致Error -26697: Missing CR/LF after body/trailer (“Transfer-Encoding: chunked”)"></a>大量并发会导致Error -26697: Missing CR/LF after body/trailer (“Transfer-Encoding: chunked”)</h2><p>原因：<br>不明。<br>解决方法：<br>未解决。</p>
<h2 id="大量并发后报错Error-27796-Failed-to-connect-to-server-“dangjian-gdaee-com-cn-8088”-10060-Connection-timed-out"><a href="#大量并发后报错Error-27796-Failed-to-connect-to-server-“dangjian-gdaee-com-cn-8088”-10060-Connection-timed-out" class="headerlink" title="大量并发后报错Error -27796: Failed to connect to server “dangjian.gdaee.com.cn:8088”: [10060] Connection timed out"></a>大量并发后报错Error -27796: Failed to connect to server “dangjian.gdaee.com.cn:8088”: [10060] Connection timed out</h2><p>网上查找的解决方法：<br>方法一：<br>在注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters里，有如下两个键值：<br>TcpTimedWaitDelay<br>MaxUserPort<br>1,这里的TcpTimedWaitDelay默认值应该中是30s，所以这里，把这个值调小为5s（按需要调整）。<br>2,也可以把MaxUserPort调大（如果这个值不是最大值的话）。<br>此法不通！</p>
<p>方法二：<br>修改run time setting中的请求超时时间Preferences 中点击Options 其中有三项的参数可以一次都修改了，HTTP-request connect timeout，HTTP-request receieve timeout，<br>Step download timeout，分别建议修改为1000、1000、10000；run time setting设置完了后记住还需要在control组件的option的run time setting中设置相应的参数；<br>此法不通！</p>
<p>原因：<br>迭加数值设置为3<br>解决方法：<br>（1）设置run time setting中的run logic中的迭加数值设置为1。<br><img src= "/img/loading.gif" data-src="/images/CapacityTestingIssues1.png" alt="img"></p>
<h2 id="运行场景最后出现error-82034-Rendezvous-release-failed"><a href="#运行场景最后出现error-82034-Rendezvous-release-failed" class="headerlink" title="运行场景最后出现error -82034 Rendezvous release failed"></a>运行场景最后出现error -82034 Rendezvous release failed</h2><p>原因：<br>集合点释放失败，可能内存太低导致。<br>解决方法：<br>（1）重新设置STOP vuser。<br>（2）修改集合点的超时时间，如由1秒改为30秒。<br><img src= "/img/loading.gif" data-src="/images/CapacityTestingIssues2.png" alt="img"></p>
<h2 id="TPS中有Action-Transaction-和-vuser-init-Transaction"><a href="#TPS中有Action-Transaction-和-vuser-init-Transaction" class="headerlink" title="TPS中有Action_Transaction 和 vuser_init_Transaction"></a>TPS中有Action_Transaction 和 vuser_init_Transaction</h2><p>原因：<br>不明。<br>解决方法：<br>（1）run time setting–Miscellaneous–Automatic Transactions在脚本和场景设置中同时勾上这两项，保存后，再去掉勾选这两项，再保存。<br><img src= "/img/loading.gif" data-src="/images/CapacityTestingIssues3.png" alt="img"></p>
<h2 id="回放数据出现错误Error-26377-No-match-found-for-the-requested-parameter-“outboundFlight”-Check-whether-the-requested-boundaries-exist-in-the-response-data-Also-if-the-data-you-want-to-save-exceeds-256-bytes-use-web-set-max-html-param-len-to-increase-the-parameter-size"><a href="#回放数据出现错误Error-26377-No-match-found-for-the-requested-parameter-“outboundFlight”-Check-whether-the-requested-boundaries-exist-in-the-response-data-Also-if-the-data-you-want-to-save-exceeds-256-bytes-use-web-set-max-html-param-len-to-increase-the-parameter-size" class="headerlink" title="回放数据出现错误Error -26377: No match found for the requested parameter “outboundFlight”. Check whether the requested boundaries exist in the response data. Also, if the data you want to save exceeds 256 bytes, use web_set_max_html_param_len to increase the parameter size"></a>回放数据出现错误Error -26377: No match found for the requested parameter “outboundFlight”. Check whether the requested boundaries exist in the response data. Also, if the data you want to save exceeds 256 bytes, use web_set_max_html_param_len to increase the parameter size</h2><p>原因：<br>开发更改接口，没有发现匹配请求的参数，响应数据中存在边界错误。<br>解决方法：<br>（1）修改边界值。<br>（2）注释掉没有匹配请求的参数。</p>
<h2 id="Error-27727-Step-download-timeout-120-seconds-has-expired-when-downloading-resource-s"><a href="#Error-27727-Step-download-timeout-120-seconds-has-expired-when-downloading-resource-s" class="headerlink" title="Error -27727: Step download timeout (120 seconds) has expired when downloading resource(s)."></a>Error -27727: Step download timeout (120 seconds) has expired when downloading resource(s).</h2><p>原因：<br>请求超时，默认是120 seconds。<br>解决方法：<br>（1）在Vuser Generator中的Vuser—&gt;Run-Time Settings…—-&gt;Internet Protocol—&gt;Preferences—-&gt;HTTP-request connect timeout (sec)和HTTP-request receive timeout (sec) 分别设置1000，Step download timeout (sec) 设置10000即可解决。</p>
<h2 id="Error-27796-Failed-to-connect-to-server-“ip地址”-10060-Connection-timed-out"><a href="#Error-27796-Failed-to-connect-to-server-“ip地址”-10060-Connection-timed-out" class="headerlink" title="Error -27796: Failed to connect to server “ip地址”: [10060] Connection timed out"></a>Error -27796: Failed to connect to server “ip地址”: [10060] Connection timed out</h2><p>原因：<br>由于下载的速度慢导致超时，所以需要调整一下超时时间。<br>解决方法：<br>（1）修改run time setting中的请求超时时间Preferences 中点击Options 其中有三项的参数可以一次都修改了，HTTP-request connect timeout，HTTP-request receieve timeout，Step download timeout，分别建议修改为1000、1000、10000；run time setting设置完了后记住还需要在control组件的option的run time setting中设置相应的参数；<br>（2）Browser Emulation 中的Download non-HTML resources 选项去掉，点击OK即可。<br>（3）如果还是不行，设置runt time setting中的internet protocol-preferences中的advaced区域有一个winlnet replay instead of sockets选项，选项后再回放就成功了。切记此法只对windows系统起作用。<br>参考博客：<a href="https://blog.csdn.net/weixin_30856965/article/details/95607767" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30856965/article/details/95607767</a></p>
<h2 id="Failed-to-Initialize-Reason-TimeOut"><a href="#Failed-to-Initialize-Reason-TimeOut" class="headerlink" title="Failed to Initialize. Reason: TimeOut"></a>Failed to Initialize. Reason: TimeOut</h2><p>原因：<br>因为某个虚拟用户在transaction初始化时超时了。<br>解决方法：<br>（1）调整 Run-timesetting－&gt;Internet Protocol－&gt;references－&gt;Advaanced－&gt;Options，将HTTP-request connect timeout,request receive timeout,和Step download timeout的时间都调成了最大1000s.<br><img src= "/img/loading.gif" data-src="/images/CapacityTestingIssues4.png" alt="img"><br>（2）除了运行时设置里的首选项高级外，还有tools-options-timeout，可以在controller-tools-timeout,修改command timeout(seconds), 可以解决初始化超时问题。<br><img src= "/img/loading.gif" data-src="/images/CapacityTestingIssues5.png" alt="img"></p>
]]></content>
      <tags>
        <tag>Loadrunning</tag>
      </tags>
  </entry>
  <entry>
    <title>Loadrunning用法</title>
    <url>/2020/08/11/LoadrunningTerms/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="一、loadrunner常用术语"><a href="#一、loadrunner常用术语" class="headerlink" title="一、loadrunner常用术语"></a>一、loadrunner常用术语</h2><p>1.场景<br>•    在loadrunner中主要表现为controller中设计与执行测试用例中的用户场景。主要工作有，在controller中选择虚拟用户脚本、设置虚拟用户数量、配置虚拟用户运行时的行为、选择负载发生器、设置执行时间等。<br>2.负载发生器<br>•    用来产生压力的真实机器，受controller控制，可以使用户脚本在不同的主机上执行。在性能测试工作中，通常由一个controller控制多个load generator以对被测试系统进行压力。<br>在练习中是对本机中进行加压<br>3.虚拟用户<br>•    对应于现实中的真实用户，使用loadrunner模拟的用户称为虚拟用户。其本质是通过虚拟用户脚本来模拟真正用户的行为。<br>4.事务<br>•    loadrunner通过事务来衡量服务器的性能。在业务上事务通常是用户的一个或一系列操作，代表一定的功能，而在程序上则表现为一段代码区块。测试人员可以将一个或多个操作步骤定义为一个事务，以便衡量这部分的用户并发响应时间。<br>5.思考时间<br>•    为了在模拟时更加接近用户的真实行为而引进的概念。在实际中，用户进行一系列操作后往往会进行处理，例如浏览网页内容，而处理过程对服务器是没有压力的。因此在虚拟用户脚本中用函数lr_think_time(double time)来模拟用户处理过程，执行该函数时用户线程会按照相应的time值进行等待。<br>6.集合点<br>•    对应于真实用户中的并发点。loadrunner通过集合点实现了真正意义的并发。集合点在虚拟用户脚本中对应函数lr_rendezvous(constchar*rendezvous_name)，当执行到该函数时会按照场景的并发策略来执行。<br>7.事务响应时间<br>•    事务响应时间是一个统计量，是评价系统性能的重要参数。定义好事务后，在场景执行过程和测试结果分析中即可看到对应事务的响应时间。通过对关键或核心事务的执行情况进行分析，可以快速定位性能问题。</p>
<h2 id="二、性能测试常见用语解析"><a href="#二、性能测试常见用语解析" class="headerlink" title="二、性能测试常见用语解析"></a>二、性能测试常见用语解析</h2><p>1.并发用户数量<br>常见的错误理解：<br>•    使用系统的全部用户数量<br>•    使用系统的全部在线用户数量<br>正确理解：<br>•    与服务器进行交互的在线用户数量<br>并发用户数：可以分两种：<br>1）同一时间点，执行同一（业务）操作的用户数<br>2）同一时间点，执行不同（业务）操作的用户数<br>在线用户：当前时间访问系统的用户数<br>2.请求响应时间<br>•    从client端发生请求到得到响应的整个时间<br>•    一般包括网络响应时间+server的响应时间<br> 响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间<br>3.事务请求响应时间<br>•    完成这个事务所用的时间<br>这是性能测试中重点关注的指标<br>4.吞吐率<br>•    单位时间在网络上传输的数据量<br>这个是衡量网络性能的主要指标<br>吞吐率指的是从server端返回client端的数据量，不是从client发送到server的数据量<br>5.吞吐量<br>•    网络上传输的数据总量<br> 吞吐量是指系统在单位时间内处理请求的数量。<br>6.TPS<br>•    每秒钟系统能够处理事务的数量<br>7.点击率<br>•    每秒发送的HTTP请求的数量<br>•    点击率越大对server的压力也就越大<br>注：按一个button并不总是发送一个请求，有时会发送两个以上HTTP请求<br>PV（Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。<br>8.资源利用率<br>•    对不同资源的使用程度，比如服务器的CPU，内存等<br>  系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间<br>       QPS（TPS）：每秒钟request/事务数量<br>       并发数： 系统同时处理的request/事务数<br>       响应时间：一般取平均响应时间<br>    理解了上面三个要素的意义之后，就能推算出它们之间的关系：<br>    QPS（TPS）= 并发数/平均响应时间</p>
]]></content>
      <tags>
        <tag>Loadrunning</tag>
      </tags>
  </entry>
  <entry>
    <title>手写loadrunning脚本</title>
    <url>/2020/07/30/LoadrunningScript/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="1、为什么要手写脚本"><a href="#1、为什么要手写脚本" class="headerlink" title="1、为什么要手写脚本"></a>1、为什么要手写脚本</h2><p>（1）浏览器兼容性不好，IE9或者以上不支持<br>（2）录制的脚本过长<br>（3）可能开发只提供接口，没有页面可以录制</p>
<h2 id="2、常用函数"><a href="#2、常用函数" class="headerlink" title="2、常用函数"></a>2、常用函数</h2><p>get的页面请求用web_url<br>表单提交web_submit_form<br>post数据请求用web_submit_data</p>
<h2 id="3、抓包工具"><a href="#3、抓包工具" class="headerlink" title="3、抓包工具"></a>3、抓包工具</h2><p>浏览器自带工具：使用Chrome或者其他浏览，F12的network列表查看请求（刷新页面可以重新查看）<br>其他专业抓包工具：HttpWatch、Fiddler、BurpSuite…</p>
<h2 id="4、loadrunner脚本创建"><a href="#4、loadrunner脚本创建" class="headerlink" title="4、loadrunner脚本创建"></a>4、loadrunner脚本创建</h2><p>（1）点击鼠标–选择Insert–选择New step–选择类型–填写信息，填入相应参数<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript1.png" alt="选择New step"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript2.png" alt="选择类型"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript3.png" alt="填写信息"><br>（2）生成脚本，并修改如下（<br>Ⅰ参数中的引号”前需要加斜杠\转译<br>如：json 对象<br>错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Value=&#123;"</span>cate<span class="string">":[&#123;"</span>fieldName<span class="string">":"</span>BACCNAME<span class="string">","</span>text<span class="string">":"</span>功能分类名称 <span class="string">"&#125;],"</span>series<span class="string">":[&#123;"</span>fieldName<span class="string">":"</span>SUMMONEY<span class="string">","</span>text<span class="string">":"</span>支出金额<span class="string">"&#125;],"</span>desc<span class="string">":[&#123;"</span>sqlField<span class="string">":false,"</span>fieldName<span class="string">":"</span>金额(万元)<span class="string">"&#125;]&#125;"</span>,</span><br></pre></td></tr></table></figure>
<p>正确：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"Value=&#123;\"cate\":[&#123;\"fieldName\":\"BACCNAME\",\"text\":\"功能分类名称 \"&#125;],\"series\":[&#123;\"fieldName\":\"SUMMONEY\",\"text\":\"支出金额\"&#125;],\"desc\":[&#123;\"sqlField\":false,\"fieldName\":\"金额(万元)\"&#125;]&#125;"</span>,</span><br></pre></td></tr></table></figure>
<p>Ⅱ手写脚本”Snapshot=”为空<br>Ⅲ扩展中是请求后的静态资源js、css、woff<br>Ⅳ脚本写好后可通过回放，验证脚本的正确性<br>可参考：<a href="https://jingyan.baidu.com/article/9158e000138687a2541228b4.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/9158e000138687a2541228b4.html</a></p>
<h2 id="5、设置测试点"><a href="#5、设置测试点" class="headerlink" title="5、设置测试点"></a>5、设置测试点</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lr_start_sub_transaction</td>
<td>标记子事务的开始</td>
</tr>
<tr>
<td>lr_start_transaction</td>
<td>标记事务的开始</td>
</tr>
<tr>
<td>lr_end_sub_transaction</td>
<td>标记子事务的结束以便进行性能分析</td>
</tr>
<tr>
<td>lr_end_transaction</td>
<td>标记 LoadRunner 事务的结束</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lr_rendezvous(<span class="string">"集合点"</span>);</span><br><span class="line">    lr_start_transaction(<span class="string">"登陆时间"</span>);</span><br><span class="line">    web_submit_form(<span class="string">"login.pl"</span>, </span><br><span class="line">        <span class="string">"Snapshot="</span>, </span><br><span class="line">        ITEMDATA, </span><br><span class="line">        <span class="string">"Name=username"</span>, <span class="string">"Value=test1"</span>, ENDITEM, </span><br><span class="line">        <span class="string">"Name=password"</span>, <span class="string">"Value=123456"</span>, ENDITEM, </span><br><span class="line">        LAST);</span><br><span class="line">lr_end_sub_transaction(<span class="string">"登陆时间"</span>,LR_ABORT);</span><br></pre></td></tr></table></figure>

<h2 id="6、设置变量参数"><a href="#6、设置变量参数" class="headerlink" title="6、设置变量参数"></a>6、设置变量参数</h2><p>（1）在loadrunner的进行编写脚本，或者一个网页登录界面进行录制脚本，录制完成之后，在脚本找登录的用户名，选中用户右键》》replace with a pararmeter。<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript4.png" alt="replace with a pararmeter"><br>（2）弹出了一个为select or create parameter的框，可以对parameter name名称重名，也可不命名。—这样在代码脚本中的用户名就变为了一种颜色，变为参数名。<br>（3）需要对参数名进行参数化，可以点击菜单中的open parameter list的按钮，点击进入。可以看到的是newparam默认的一个参数了为xinling，需要在行中在添加数据，可点击add row添加行，输入数据双击value就可进行输入，输入网页中其它的用户名。<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript5.png" alt="设置参数"><br>（4）参数化数据准备好之后，就进行执行了，在执行前，需要到run-time settings设置的界面中，run logic的选项界面中，把循环的次数改为2次，因准备数据只有两条了。<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript6.png" alt="run-time settings"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript7.png" alt="设置循环测试"><br>（5）设置完成之后，可以点击loadrunner的界面中菜单运行按钮，等待脚本完成之后，可以在执行log看到执行的结果数据，是成功执行成功的。<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript8.png" alt="执行结果"></p>
<h2 id="7、字符串参数化例子"><a href="#7、字符串参数化例子" class="headerlink" title="7、字符串参数化例子"></a>7、字符串参数化例子</h2><h3 id="1）对登录账号参数化"><a href="#1）对登录账号参数化" class="headerlink" title="1）对登录账号参数化"></a>1）对登录账号参数化</h3><p>（1）确定参数<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript9.png" alt="确定参数"><br>（2）新建参数，选中字符串点击鼠标右键，选择“replace with a parameter”菜单<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript10.png" alt="新增参数"><br>（3）在弹框中填写参数名称，点击“OK”完成参数化<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript11.png" alt="填写参数名称"><br>（4）参数化后，字符串被参数名替换<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript12.png" alt="参数名替换"><br>（5）快捷键“ctrl+L”查看参数列表<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript13.png" alt="查看参数列表"></p>
<h3 id="2）密码参数化，与账号关联，使用户名和密码对应，便可登录成功"><a href="#2）密码参数化，与账号关联，使用户名和密码对应，便可登录成功" class="headerlink" title="2）密码参数化，与账号关联，使用户名和密码对应，便可登录成功"></a>2）密码参数化，与账号关联，使用户名和密码对应，便可登录成功</h3><p>（1）选中字符串点击鼠标右键，选择“replace with a parameter”菜单<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript14.png" alt="选择“replace with a parameter”"><br>（2）在弹框上填写名称，点击“properties…”打开配置窗口<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript15.png" alt="打开配置窗口"><br>（3）参数配置窗口，file选择用户名参数的文件<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript16.png" alt="选择用户名参数的文件"><br>（4）添加一列用于存放密码，点击“add column…”按钮，点击“OK”确认添加<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript17.png" alt="add column..."><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript18.png" alt="添加字段"><br>（5）配置select next row选项为“same line as username”，即下一行数据选择与用户名同一行，点击“close”<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript19.png" alt="select next row"><br>（6）点击“OK”完成密码参数化<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript20.png" alt="完成密码参数化"><br>（7）密码字符串被参数替换<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript21.png" alt="密码字符串被参数替换"><br>（8）查看参数列表（ctrl+L）<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript22.png" alt="查看含密码的参数列表"></p>
<h2 id="8、关联函数"><a href="#8、关联函数" class="headerlink" title="8、关联函数"></a>8、关联函数</h2><h3 id="一、什么是关联"><a href="#一、什么是关联" class="headerlink" title="一、什么是关联"></a>一、什么是关联</h3><p>关联（correlation）：脚本回放过程中，客户端发出请求，通过关联函数所定义的左右边界值（也就是关联规则），在服务器所响应的内容中查找，得到相应的值，已变量的形式替换录制时的静态值，从而向服务器发出正确的请求，这种动态获得服务器响应内容的方法被称作关联。也是把脚本中某些写死的数据，转变成动态的数据。<br>什么内容需要关联：当脚本中的数据每次回放都发生变化时，并且这个动态数据在后面的请求中需要发送给服务器，那么这个内容需要通过关联来询问服务器，获得该数据的变化结果。<br>例如：<br>1.登录字符串。带有会话 ID 或时间戳等动态数据的登录字符串。<br>2.日期/时间戳。使用日期或时间戳或者其他用户凭据的任意字符串。<br>3.常见前缀。后跟字符串的常见前缀，如 SessionID 或 CustomerID。</p>
<h3 id="二、web-reg-save-param函数说明"><a href="#二、web-reg-save-param函数说明" class="headerlink" title="二、web_reg_save_param函数说明"></a>二、web_reg_save_param函数说明</h3><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int web_reg_save_param(<span class="keyword">const</span> char *ParamName, &lt;list <span class="keyword">of</span> Attributes&gt;, LAST);</span><br></pre></td></tr></table></figure>
<p>参数说明:<br>· ParamName: 存放得到的动态内容的参数名称。<br>· list of Attributes: 其它属性，包括：Notfound, LB, RB, RelFrameID, Search, ORD, SaveOffset, Convert, SaveLen。属性值不分大小写。<br>o Notfound: 当在返回信息中找不到要找的内容时应该怎么处理。<br>o Notfound=error: 当在返回信息中找不到要找的内容时，发出一个错误讯息。这是缺省值。<br>o Notfound=warning: 当在返回信息中找不到要找的内容时，只发出警告，脚本也会继续执行下去不会中断。<br>o LB( Left Boundary ) : 返回信息的左边界字串。该属性必须有，并且区分大小写。<br>o RB( Right Boundary ): 返回信息的右边界字串。该属性必须有，并且区分大小写。<br>o RelFrameID: 相对于URL而言，欲查找的网页的Frame。此属性质可以是All或是数字，该属性可有可无。<br>o Search : 返回信息的查找范围。可以是Headers，Body，Noresource，All(缺省)。该属性质可有可无。<br>o ORD : 说明第几次出现的左边界子串的匹配项才是需要的内容。该属性可有可无，缺省值是1。如为All，则将所有找到的内容储存起来。<br>o SaveOffset : 当找到匹配项后，从第几个字元开始存储到参数中。该属性不能为负数，缺省值为0。<br>o SaveLen ：当找到匹配项后，偏移量之后的几个字元存储到参数中。缺省值是-1，表示一直到结尾的整个字串都存入参数。</p>
<h3 id="三、实例分析"><a href="#三、实例分析" class="headerlink" title="三、实例分析"></a>三、实例分析</h3><p>1）查看页面源码 (PC端登录页面，获取用户id)<br>（1）在浏览器上登录到首页，查看源码<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript23.png" alt="查看源码"><br>（2）查到需获取的字符串（在页面上搜索）<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript24.png" alt="获取的字符串"><br>（3）确定左边界、右边界 及 字符串的数量（LB/RB/ORD）<br>左边界LB=userid=<br>右边界RB=’;<br>数量为1，ord缺省</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web_reg_save_param(</span><br><span class="line">       <span class="string">"userid"</span>,</span><br><span class="line">       <span class="string">"LB=userid="</span>,</span><br><span class="line">       <span class="string">"RB=';"</span>,</span><br><span class="line">       LAST)</span><br></pre></td></tr></table></figure>
<p>2）调试脚本<br>（1）添加消息打印，打印参数值，设置断点（F9）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lr_output_message(<span class="string">"userid=%s"</span>,lr_eval_string(<span class="string">"&#123;userid&#125;"</span>));</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/LoadrunningScript25.png" alt="调试脚本"><br>（2）F5回放脚本，查看replay log中消息打印结果<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript26.png" alt="F5回放脚本"><br>（3）修改用户密码（即{username}和{password}的值），重新回放脚本，查看replay log消息打印结果（验证接口请求正确）<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript27.png" alt="查看replay log消息打印结果"><br>调试结果通过的判定条件：<br>1、web_submit_data执行成功，<br>2、打印出来的参数值与页面源码中的值一致<br>3）关联参数有多个参数时，注意一下操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web_reg_save_param(<span class="string">"TypeId"</span>,<span class="string">"LB=\"type\":\""</span>,<span class="string">"RB=\",LAST);</span></span><br><span class="line"><span class="string">web_submit_data()；</span></span><br><span class="line"><span class="string">lr_output_message("</span>TypeId=%s<span class="string">",lr_eval_string("</span>&#123;TypeId&#125;<span class="string">"));</span></span><br></pre></td></tr></table></figure>
<p>直接关联没有加”ORD=all”获取到的是第一个参数，不会获取其他参数；加上”ORD=all”，获取所有参数，以数组形成保存，可通过数组下标进行获取如{TypeId_1}。具体如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web_reg_save_param(<span class="string">"TypeId"</span>,<span class="string">"LB=\"type\":\""</span>,<span class="string">"RB=\","</span>ORD=all<span class="string">",LAST);</span></span><br><span class="line"><span class="string">web_submit_data()；</span></span><br><span class="line"><span class="string">lr_output_message("</span>TypeId=%s<span class="string">",lr_eval_string("</span>&#123;TypeId_1&#125;<span class="string">"));</span></span><br></pre></td></tr></table></figure>
<p>4）如何取值LB、RB<br>1、不取变量值<br>2、不取中文<br>3、字段长度10个字符左右<br>5）转换说明符<br>| 转换说明符 | 说明                                    |<br>| ———- | ————————————— |<br>| %a(%A)     | 浮点数、十六进制数字和p-(P-)记数法(C99) |<br>| %c         | 字符                                    |<br>| %d         | 有符号十进制整数                        |<br>| %f         | 浮点数(包括float和doulbe)               |<br>| %e(%E)     | 浮点数指数输出[e-(E-)记数法]            |<br>| %g(%G)     | 请求头浮点数不显无意义的零”0”           |<br>| %i         | 有符号十进制整数(与%d相同)              |<br>| %u         | 无符号十进制整数                        |<br>| %o         | 八进制整数    e.g.     0123             |<br>| %x(%X)     | 十六进制整数0f(0F)   e.g.   0x1234      |<br>| %p         | 指针                                    |<br>| %s         | 字符串                                  |<br>| %%         | “%”                                     |<br>其中常用的主要是%d和%s，其他进行了解。</p>
<h2 id="9、验证回放数据"><a href="#9、验证回放数据" class="headerlink" title="9、验证回放数据"></a>9、验证回放数据</h2><p>1）    查看请求是否成功<br>查看replay log消息，查看接口是否请求成功<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript28.png" alt="查看replay log消息"><br>回放https的问题：<a href="https://jingyan.baidu.com/article/9158e000138687a2541228b4.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/9158e000138687a2541228b4.html</a><br>如遇到其他问题可自行百度处理<br>2）查看数据是否正确<br>（1）打开回放的显示窗口<br>步骤：点击tools—点击general options—选择display—勾选show run-time viewer during re]和auto arrange windo—打开回放的显示窗口<br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript29.png" alt="点击general options"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningScript30.png" alt="选择display"><br>（2）查看回放返回的数据与页面接口请求返回中的值是否一致</p>
]]></content>
      <tags>
        <tag>Loadrunning</tag>
      </tags>
  </entry>
  <entry>
    <title>本地化测试</title>
    <url>/2020/11/18/LocalizationTesting/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Localization testing（本地化测试），本地化测试的对象是软件的本地化版本。本地化测试的目的是测试特定目标区域设置的软件本地化质量。本地化测试的环境是在本地化的操作系统上安装本地化的软件。从测试方法上可以分为基本功能测试，安装/卸载测试，当地区域的软硬件兼容性测试。测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和联机帮助等部分。<br>本地化就是翻译产品的 UI，有时也更改某些初始设置以使产品适合于另一个地区。本地化测试检查针对特定目标区域性或区域设置的产品本地化质量。此测试基于全球化测试的结果，后者验证对特定区域性或区域设置的功能性支持。本地化测试只能在产品的本地化版本上进行。可本地化性测试不对本地化质量进行测试。<br>本地化测试过程中的测试工作集中在：<br>• 受本地化影响的方面，如 UI 和内容<br>• 区域性或区域设置特定的、语言特定的和地区特定的方面<br>另外，本地化测试还应包括：<br>• 基本功能测试<br>• 在本地化环境中运行的安装和升级测试<br>• 根据产品的目标地区计划应用程序和硬件兼容性测试。<br>可以选择 Windows 2000 的任何语言版本作为测试平台。然而，必须安装目标语言支持。<br>用户界面和语言的本地化测试应包括的项有：<br>• 验证所有应用程序资源<br>• 验证语言的准确性和资源属性<br>• 版式错误<br>• 书面文档、联机帮助、消息、界面资源、命令键顺序等的一致性检查。<br>• 确认是否遵守系统、输入和显示环境标准<br>• 用户界面可用性<br>• 评估文化适合性<br>• 检查政治上敏感的内容<br>当交付本地化产品时，确保包含本地化文档（手册、联机帮助、上下文帮助等）。要检查的项包括：<br>• 翻译的质量<br>• 翻译的完整性<br>• 所有文档和应用程序 UI 中使用的术语一致</p>
<h2 id="二、软件本地化测试的内容构成"><a href="#二、软件本地化测试的内容构成" class="headerlink" title="二、软件本地化测试的内容构成"></a>二、软件本地化测试的内容构成</h2><p>1、软件本地化测试的目的<br>保证本地化的软件与源语言软件具有相同的功能和性能。<br>保证本地化的软件在语言、文化、传统观念等方面符合当地用户的习惯。<br>2、软件本地化测试的测试策略<br>本地化软件要在各种本地化操作系统上安装并测试。<br>源语言软件安装在另一台相同源语言操作系统上，作为对比测试。<br>重点测试因本地化引起的软件功能和软件界面的错误。<br>测试本地化软件的翻译质量。<br>手工测试和自动测试相结合。<br>3、软件本地化测试的主要内容<br>测试内容由不同的测试阶段决定，例如第一个Build，以软件界面测试为主，中间Build以功能和界面为主，最后Build终点测试安装/卸载，软件帮助和主要功能。<br>4、安装/卸载性能测试<br>测试本地化的软件是否可以正确地安装/卸载在本地语言的操作系统上（包括是否支持本地语言的安装目录名）。安装/卸载前后安装文件、快捷方式、程序图标和注册表等的变化是否与源语言程序一致。<br>5、软件功能测试<br>本地化软件功能是否与源语言软件功能相同。<br>是否支持当地语言的输入和输出，如对双字节支持和正确显示。<br>对当地日期，时间，货币符号等的支持性能。<br>是否支持当地语言的文件名和目录名。<br>6、软件界面测试<br>软件安装窗口中的按钮，菜单等的布局是否合理，美观。<br>软件运行后的界面元素，包括菜单、快捷键、对话框、屏幕提示、按钮、列表框的布局和本地化字体和字号是否正确。界面文字的翻译是否与术语表一致，是否存在没有翻译的元素。<br>7、帮助文件功能和翻译质量<br>本地化帮助文件的功能是否与源语言软件一致。<br>本地化帮助文件的布局是否合理，美观。<br>本地化帮助文件的文字翻译是否准确、专业，是否存在没有翻译的段落。</p>
<h2 id="四、软件本地化测试类型解析与测试要领"><a href="#四、软件本地化测试类型解析与测试要领" class="headerlink" title="四、软件本地化测试类型解析与测试要领"></a>四、软件本地化测试类型解析与测试要领</h2><p>软件本地化测试是在本地化的操作系统上对本地化的软件版本进行的测试。根据软件本地化项目的规模、测试阶段以及测试方法，本地化测试分为多种类型，每种类型都对软件本地化的质量进行检测和保证。为了提高测试的质量，保证测试的效率，不同类型的本地化测试需要使用不同的方法，掌握必要的测试技巧。本文主要选取本地化测试中具有代表性的测试类型进行分析，结合软件本地化项目的测试经验对其测试要领进行剖析。<br>1、  导航测试<br>导航测试（Pilot Testing）是为了降低软件本地化的风险而进行的一种本地化测试。大型的全球化软件在完成国际化设计后，通常选择少量的典型语言进行软件的本地化，以此测试软件的可本地化能力，降低多种语言同时本地化的风险。<br>导航测试尤其是用于数十种语言本地化的新开发的软件，导航测试版本的语言主要由语言市场的重要性和规模确定，也要考虑语言编码等的代表性。例如，德语市场是欧洲的重要市场，通常作为导航测试的首要单字节字符集语言。日语是亚洲重要的市场，可以作为双字节字符集语言代表。随着中国国内软件市场规模的增加，国际软件开发商逐渐对简体中文本地化提高重视程度，简体中文有望更多成为导航测试的首选语言。<br>导航测试是软件本地化项目早期进行的探索性测试，需要在本地化操作系统上进行，测试的重点是软件的国际化能力和可本地化能力，包括与区域相关的特性的处理能力，也包括测试是否可以容易地进行本地化，减少硬编码等缺陷。由于导航测试在整个软件本地化过程中意义重大，而且导航测试的持续时间通常较短，另外由于是新开发的软件的本地化测试，测试人员对软件的功能和使用操作了解不多，因此，本地化公司通常需要在正是测试之前进行搜集和学习软件的相关资料，做好测试环境和人员的配备，配置具有丰富测试经验的工程师执行测试。<br>2、可接受性测试<br>本地化软件的可接受性测试（Build Acceptable Testing）也称作冒烟测试（Smoke Testing），是指对编译的软件本地化版本的主要特征进行基本测试，从而确定版本是否满足详细测试的条件。理论上，每个编译的本地化新版本在进行详细测试之前，都需要进行可接受性测试，以便早期发现软件版本的可测试性，避免不必要的时间浪费。<br>注意，软件本地化版本的可接受性测试与软件公司为特定客户定制开发的原始语言软件在交付客户前的验收测试完全不同，验收测试主要确定软件的功能和性能是否达到了客户的需求，如果一切顺利，只进行一次验收测试就可以结束。<br>本地化软件在编译后，编译工程师通常需要执行版本健全性检查（Build Sanity Check），确定本地化版本的内容和主要功能可以用于测试。而编译的本地化版本是否真的满足测试条件则还要通过独立的测试人员进行可接受性测试，它要求测试人员在较短的时间内完成，确定本地化的软件版本是否满足全面测试的要求，是否正确包含了应该本地化的部分。如果版本通过了可接受性测试，则可以进入软件全面详细测试阶段，反之，则需要重新编译本地化软件版本，直到通过可接受性测试。<br>在进行本地化软件版本的可接受性测试时，需要配置正确的测试环境（软件和硬件），在本地化的操作系统上安装软件，确定是否可以正确安装。软件运行软件，确定软件包含了应该本地化的全部内容，并且主要功能正确。然后，卸载软件，保证软件可以彻底卸载。软件的完整性是需要注意的一个方面，通过使用文件和文件夹的比较工具软件，对比安装后的本地化软件和英文软件内容的异同，确定本地化的完整性。<br>3、语言质量测试<br>语言质量测试是软件本地化测试的重要组成部分，贯穿于本地化项目的各个阶段。语言质量测试的主要内容是软件界面和联机帮助等文档的翻译质量，包括正确性、完整性、专业性和一致性。<br>为了保证语言测试的质量，应该安排本地化语言作为母语的软件测试工程师进行测试，同时请本地化翻译工程师提供必要的帮助。在测试之前，必须阅读和熟悉软件开发商提供的软件术语表（Glossary），了解软件翻译风格（Translation Style）的语言表达要求。<br>由于软件的用户界面总是首先进行本地化，因此，本地化测试的初期的软件版本的语言质量测试主要以用户界面的语言质量为主，重点测试是否存在未翻译的内容，翻译的内容是否正确，是否符合软件术语表和翻译风格要求，是否符合母语表达方式，是否符合专业和行业的习惯用法。<br>本地化项目后期要对联机帮助和相关文档（各种用户使用手册等）进行本地化，这个阶段的语言质量测试，除了对翻译的表达正确性和专业性进行测试之外，还有注意联机帮助文件和软件用户界面的一致性。如果对于某些软件专业术语的翻译存在疑问，需要报告一个翻译问题，请软件开发商审阅，如果确认是翻译错误，需要修改术语表和软件的翻译。<br>关于本地化软件的语言质量测试，一个值得注意的问题是“过翻译”，就是软件中不应该翻译的内容（例如软件的名称等）如果进行了翻译，应该报告软件“过翻译”错误。<br>4、用户界面测试<br>本地化软件的用户界面测试（UI Testing），也称作外观测试（Cosmetic Testing）主要对软件的界面文字和控件布局（大小和位置）进行测试。用户界面至少包括软件的安装和卸载界面、软件的运行界面和软件的联机帮助界面。软件界面的主要组成元素包括窗口、对话框、菜单、工具栏、状态栏、屏幕提示文字等内容。<br>用户界面的布局测试是本地化界面测试的重要内容，由于本地化的文字通常比原始开发语言长度增长，所以一类常见的本地化错误是软件界面上的文字显示不完整，例如，按钮文字只显示一部分。另一类常见的界面错误是对话框中的控件位置排列不整齐，大小不一致。<br>相对于其他类型的本地化测试，用户界面测试可能是最简单的测试类型，软件测试工程师不需要过多的语言翻译知识和测试工具，但是由于软件的界面众多，而且某些对话框可能隐藏的比较深入，因此，软件测试工程师必须尽可能地熟悉被测试软件的使用方法，这样才能找出那些较为隐蔽的界面错误。另外，某个界面错误可能是一类错误，需要报告一个综合的错误，例如，软件安装界面的“上一步”或“下一步”按钮显示不完整，则可能所有安装对话框的同类按钮都存在相同的错误。<br>5、功能测试<br>原始语言开发的软件的功能测试主要测试软件的各项功能是否实现以及是否正确，而本地化软件的功能测试主要测试软件经过本地化后，软件的功能是否与源软件一致，是否存在因软件本地化而产生的功能错误，例如，某些功能失效或功能错误。<br>本地化软件的功能测试相对于其他测试类型具有较大难度，由于大型软件的功能众多，而且有些功能不经常使用，可能需要多步组合操作才能完成，因此本地化软件的功能测试需要测试工程师熟悉软件的使用操作，对于容易产生本地化错误之处能够预测，以便减少软件测试的工作量，这就要求测试工程师具有丰富的本地化测试经验。<br>除了某些菜单和按钮的本地化功能失效错误外，本地化软件的功能错误还包括软件的热键和快捷键错误，例如，菜单和按钮的热键与源软件不一致或者丢失热键。另外一类是排序错误，例如，排序的结果不符合本地化语言的习惯。<br>发现本地化功能错误后，需要在源软件上进行相同的测试，如果源软件也存在相同的错误，则不属于本地化功能错误，而属于源软件的设计错误，需要报告源软件的功能错误。另外，如果同时进行多种本地化语言（例如，简体中文、繁体中文、日文和韩文）的测试，在一种语言上的功能错误也需要在其他语言版本上进行相同的测试，以确定该错误是单一语言特有的，还是许多本地化版本共有的错误。<br>软件的测试类型数量众多，可谓五花八门，而软件本地化测试又具有其自身的特点，除以上常见的本地化测试类型外，还包括联机帮助测试、本地化能力测试等测试。不论何种类型的本地化测试，其最终测试目标都是尽早找出软件本地化错误，保证本地化软件与原始开发语言软件具有相同的功能。通过正确配置本地化测试环境，合理组织本地化测试人员，采用正确的本地化流程和测试工具，完善软件缺陷的报告和跟踪处理，有助于保证软件本地化测试的有效实现。</p>
<h2 id="五、本地化测试软件缺陷分类详解"><a href="#五、本地化测试软件缺陷分类详解" class="headerlink" title="五、本地化测试软件缺陷分类详解"></a>五、本地化测试软件缺陷分类详解</h2><p>本地化测试发现的软件缺陷特征明显，便于分类。本文按照本地化测试软件缺陷的特征进行分类，周详地分析各种缺陷的表现特征，简要描述各类缺陷的产生原因，最后给出各类缺陷的修正方法。<br>1.缺陷类型<br>概括地讲，软件本地化的缺陷主要分为两大类：核心缺陷和本地化缺陷。<br>2.缺陷表现特征<br>由于本地化缺陷是本地化测试中出现的数量最多的缺陷，所以首先分析本地化缺陷的表现特征。而本地化测试中发现的核心缺陷虽然数量不多，不过他们的危害程度更大，所以需要认真对待，接下来分析他们的表现特征。<br>2.1用户界面缺陷<br>控件的文字被截断(Truncation)<br>对话框中的文本框、按钮、列表框、状态栏中的本地化文字只显示一部分<br>控件或文字没有对齐(Misaligned)<br>对话框中的同类控件或本地化文字没有对齐<br>控件位置重叠(Overlapped)<br>对话框中的控件彼此重叠<br>多余的文字(Extra strings)<br>软件程式的窗口或对话框中的出现多余的文字<br>丢失的文字(Missed strings)<br>软件程式的窗口或对话框中的文字部分或全部丢失<br>不一致的控件布局(Inconsistent layout)<br>本地化软件的控件布局和源语言软件不一致<br>丢失的文字(Missed strings)<br>软件程式的窗口或对话框中的文字部分或全部丢失<br>文字的字体、字号错误(Incorrect font name and font size)<br>控件的文字显示不美观，不符合本地化语言的正确字体和字号<br>多余的空格(Extra space)<br>本地化文字字符之间存在多余的空格<br>2.2语言质量缺陷<br>字符没有本地化(Unlocalized strings)<br>对话框或软件程式窗口中的应该本地化的文字没有本地化<br>字符不完整地本地化(Incomplete localized strings)<br>对话框或软件程式窗口中的应该本地化的文字只有一部分本地化<br>错误的本地化字符(Error localization)<br>源语言文字被错误地本地化，或对政治敏感的文字错误地进行了本地化<br>不一致的本地化字符(Inconsistent localized string)<br>相同的文字前后翻译不一致<br>相同的文字各语言之间不一致<br>相同的文字软件用户界面和联机帮助文件不一致<br>过度本地化(Over localization)<br>不应该本地化的字符进行了本地化<br>标点符号、版权、商标符号错误(Incorrect punctuation, Copyright)<br>标点符号、版权和商标的本地化不符合本地化语言的使用习惯<br>2.3本地化功能缺陷<br>本地化功能缺陷是本地化软件中的某些功能不起作用，或功能错误，和源语言功能不一致。<br>功能不起作用(Not working)<br>菜单、对话框的按钮、超链接不起作用<br>功能错误(Error function)<br>菜单、对话框的按钮、超链接引起程式崩溃<br>菜单、对话框的按钮、超链接带来和源语言软件不一致的错误结果<br>超链接没有链接到本地化的网站或页面<br>软件的功能不符合本地化用户的使用需求<br>热键和快捷键错误(Error hot keys and short-cut keys)<br>菜单或对话框中存在重复的热键<br>本地化软件中缺少热键或快捷键<br>不一致的热键或快捷键<br>快捷键或快捷键无效<br>2.4源语言功能缺陷<br>源语言功能缺陷是在源语言软件和全部本地化软件上都能复现的错误。<br>功能不起作用(Not working)<br>菜单不起作用<br>对话框的按钮不起作用<br>超链接不起作用<br>控件焦点跳转顺序(Tab键)不正确<br>文字内容错误(Incorrect strings)<br>软件的名称或版本编号错误<br>英文拼写错误、语法错误<br>英文用词不恰当等<br>2.5源语言国际化缺陷<br>源语言国际化缺陷是在源语言软件设计过程中对软件的本地化能力的处理不足引起的，他只出目前本地化的软件中。<br>区域设置错误(Error regional setting)<br>本地化日期格式错误<br>本地化时间格式错误<br>本地化数字格式(小数点、千位分隔符)错误<br>本地化货币单位或格式错误<br>本地化度量单位错误<br>本地化纸张大小错误<br>本地化电话号码和邮政编码错误<br>双字节字符错误(Error DBCS)<br>不支持双字节字符的输入<br>双字节字符显示乱码<br>不能保存含有双字节字符内容的文件<br>不能打印双字节字符<br>3.缺陷产生原因<br>核心缺陷是由于源程式软件编码错误引起的，例如研发人员对于某个功能模块的编码错误，或没有考虑软件的国际化和本地化能力，而将代码设定为某一种语言;<br>本地化缺陷是由于软件本地化过程引起的，例如语言翻译质量较差、界面控件布局不当、翻译了程式中的变量等。<br>4.缺陷修正方法<br>本地化缺陷是测试中发现的数量最多的Bug，他只出目前本地化的版本上，而不出目前源语言版本上，能由本地化工程师修改本地化软件相关资源文件解决，例如修改错误的翻译文字、调整控件的大小和位置等。<br>核心缺陷中的源语言功能缺陷既出目前本地化软件，也能在源语言软件上复现，而核心缺陷中的源语言国际化缺陷，虽然只出目前本地化版本中，不过只能通过修改程式代码实现，属于源语言软件的设计错误，这类缺陷只能由软件研发人员修正。 </p>
<p>转载：<a href="http://wenku.baidu.com/view/7c31c80b763231126fdb1107.html" target="_blank" rel="noopener">http://wenku.baidu.com/view/7c31c80b763231126fdb1107.html</a></p>
]]></content>
      <tags>
        <tag>功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Loadrunning收集数据</title>
    <url>/2020/08/11/LoadrunningToCollectData/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="服务器监控数据"><a href="#服务器监控数据" class="headerlink" title="服务器监控数据"></a>服务器监控数据</h2><h3 id="（一）准备监控工具"><a href="#（一）准备监控工具" class="headerlink" title="（一）准备监控工具"></a>（一）准备监控工具</h3><p>1.打开crt，择新建连接 ；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData1.png" alt="img"><br>2.输入IP地址， IP地址为：192.168.1.210；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData2.png" alt="img"><br>3.输入用户名及，点击OK；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData3.png" alt="img"><br>4.输入账号密码：wjl/123456，可点击保存密码，这时已经登录上了；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData4.png" alt="img"></p>
<h3 id="（二）监控命令"><a href="#（二）监控命令" class="headerlink" title="（二）监控命令"></a>（二）监控命令</h3><p>1.先在crt界面输入命令dstat -tcdnm -output xxxx.csv（如181116jzdl.csv注：命名要规范181116表示当天时间，jz表示基准测试，dl表示场景名称，如果是容量测试，可加上用户数量（181116rldl20.csv位置可自己喜好来调整；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData5.png" alt="img"><br>2.再打开controller点击开始场景；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData6.png" alt="img"><br>3.回到crt运行之前输入的命令（回车， 查看idl（空闲CPU，目标CPU占用率：≤80%<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData7.png" alt="img"><br>4.当场景运行完毕，则在crt这边Ctrl+C停止日志输出。<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData8.png" alt="img"></p>
<h3 id="（三）数据保存整理"><a href="#（三）数据保存整理" class="headerlink" title="（三）数据保存整理"></a>（三）数据保存整理</h3><p>1.crt输入下载命令sz rlxzsp20log.csv，择保存路径，可把日志文件下载到本地，该文件可用excel打开编辑；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData9.png" alt="img"><br>打开后：<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData10.png" alt="img"><br>2.先在gh之间新增一列用在存放CPU的使用率：<br>计算公式为：（user+sys/sum（CPU总数回车得到CPU使用率；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData11.png" alt="img"><br>照下图操作；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData12.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData13.png" alt="img"><br>这些多余的数据需要删掉；<br>（判断方法的话，一般运行场景的压测的时候，CPU会有明显的变化。简单来说，你启动运行场景和结束场景运行，这个前后时间里，监控命令是否有多出的监控信息。）<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData14.png" alt="img"><br>3.再求出CPU使用率的平均值，再求出内存使用率的平均值；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData15.png" alt="img"><br>4.在求内存使用率：计算公式为：used/sum（总数；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData16.png" alt="img"><br>5.再求内存使用率平均值；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData17.png" alt="img"><br>6.把CPU使用率的平均值和内存使用率平均值填到测试报告的表格里；<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData18.png" alt="img"><br>计算网络利用率，公式为send/(2.56<em>1024</em>1024)<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData19.png" alt="img"></p>
<h3 id="（四）遇到的问题"><a href="#（四）遇到的问题" class="headerlink" title="（四）遇到的问题"></a>（四）遇到的问题</h3><p>1.执行监控命令<br>[root@localhost /]# dstat -tcdnm 200805jzdl.csv<br>-bash: dstat: 未找到命令<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData20.png" alt="img"><br>2.安装dstat<br>yum install -y dstat<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData21.png" alt="img"><br>3.上传文件到linux服务器<br>securecrt 按下ALT+P就开启新的会话 进行ftp操作。<br>输入put C:/Users/Administrator/Desktop/dstat-0.7.2-12.el7.noarch.rpm上传<br>上传成功，在查看所在位置：pwd<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData22.png" alt="img"><br>4.安装<br>输入rpm -ivh dstat-0.7.2-12.el7.noarch.rpm进行安装<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData23.png" alt="img"><br>5.监控<br>dstat -tcdnm -output xxxx.csv<br>dstat -tcdnm xxxx.csv<br>执行后都报错<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData24.png" alt="img"><br>执行dstat、dstat -tcdnm都成功<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData25.png" alt="img"><br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData26.png" alt="img"><br>发现output需要—output才能执行<br>执行dstat -tcdnm –output xxxx.csv成功<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData27.png" alt="img"><br>5.从linux服务器下载文件<br>securecrt 按下ALT+P就开启新的会话 进行ftp操作。<br>输入get 200805jzdl.csv下载<br><img src= "/img/loading.gif" data-src="/images/LoadrunningToCollectData28.png" alt="img"><br>其他应用了解地址：<a href="https://wenwen.sogou.com/z/q799956086.htm" target="_blank" rel="noopener">https://wenwen.sogou.com/z/q799956086.htm</a></p>
]]></content>
      <tags>
        <tag>Loadrunning</tag>
      </tags>
  </entry>
  <entry>
    <title>启用 Valine 留言系统</title>
    <url>/2020/08/20/MessageBoard/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>博客应用blank主题，主题含有Valine 留言系统，功能提示：Code 401: 未经授权的操作，请检查你的AppId和AppKey.<br><img src= "/img/loading.gif" data-src="/images/MessageBoard1.png" alt="img"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>创建 LeanCloud 应用</strong><br>Valine 基于 LeanCloud 提供的数据服务，参考 Valine 的 <a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">官方教程</a>，首先前往 <a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud.cn</a> 注册账号。<br>我选择的是华东节点，提交注册信息后LeanCloud提示国区账号必需实名制，否则无法创建应用。<br>创建了一个应用，命名为 <code>Valine</code>，方案选择开发版，即可以在一定的用量限制下免费运行。<br><img src= "/img/loading.gif" data-src="/images/MessageBoard2.png" alt="img"><br>进入创建好的应用，就能获取到 <code>App ID</code> 和 <code>App Key</code>。<br>步骤：<br>(1)进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用``Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了。<br><img src= "/img/loading.gif" data-src="/images/MessageBoard3.png" alt="img"><br>(2)然后，进入 <code>设置</code> &gt; <code>安全中心</code> &gt; <code>Web ``安全域名</code>，填写站点的域名并保存：<br><img src= "/img/loading.gif" data-src="/images/MessageBoard4.png" alt="img"><br><strong>配置博客</strong><br>编辑 <code>source/_data/blank.yml</code>，找到对应的模块，修改配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">    enable: <span class="literal">true</span> </span><br><span class="line">    appid: <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">ID</span>&gt;</span></span></span><br><span class="line">    appkey: &lt;App Key&gt;</span><br><span class="line">    notify: false </span><br><span class="line">    verify: false </span><br><span class="line">    placeholder: &lt;留言编辑框里的默认文本&gt;</span><br><span class="line">    avatar: mm </span><br><span class="line">    guest_info: nick,mail,link </span><br><span class="line">    pageSize: 10 </span><br><span class="line">    recordIP: false </span><br><span class="line">    serverURLs:</span><br><span class="line">    emojiCDN: </span><br><span class="line">    enableQQ: true</span><br></pre></td></tr></table></figure>
<p>再次部署 Hexo 后就能看到留言系统已经启用，可以进行留言了。<br><img src= "/img/loading.gif" data-src="/images/MessageBoard5.png" alt="img"><br><strong>查看数据</strong><br>发表留言后，进入 <code>存储</code> &gt; <code>结构化数据</code> &gt; <code>comment</code>，可对数据进行操作。<br><img src= "/img/loading.gif" data-src="/images/MessageBoard6.png" alt="img"></p>
<p>参考博客：<a href="https://laytonsun.com/learning/2019-08/enable-comments.html" target="_blank" rel="noopener">https://laytonsun.com/learning/2019-08/enable-comments.html</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman接口测试</title>
    <url>/2020/06/07/Postman/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="1、什么是接口"><a href="#1、什么是接口" class="headerlink" title="1、什么是接口"></a>1、什么是接口</h2><p>用于处理各个系统各个模块之间的数据。</p>
<h2 id="2、接口的组成"><a href="#2、接口的组成" class="headerlink" title="2、接口的组成"></a>2、接口的组成</h2><table>
<thead>
<tr>
<th>组成</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>URL</td>
<td>接口地址</td>
</tr>
<tr>
<td>Method</td>
<td>接口类型</td>
</tr>
<tr>
<td>Code</td>
<td>状态码</td>
</tr>
<tr>
<td>Headers</td>
<td>请求头</td>
</tr>
<tr>
<td>Response</td>
<td>返回数据</td>
</tr>
<tr>
<td>Data</td>
<td>接口发送数据</td>
</tr>
</tbody></table>
<h2 id="3、Postman基础用法介绍"><a href="#3、Postman基础用法介绍" class="headerlink" title="3、Postman基础用法介绍"></a>3、Postman基础用法介绍</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="(1)用法"></a>(1)用法</h3><p>选择接口类型，填写接口地址、请求头，点击send可获取返回数据。</p>
<h3 id="2-发送数据的接口"><a href="#2-发送数据的接口" class="headerlink" title="(2)发送数据的接口"></a>(2)发送数据的接口</h3><p>①Get的发送数据<br>发送的数据之间写在URL，通过“？”间隔数据和地址<br>参数和参数之间用“&amp;”间隔（也可通过params直接输入）</p>
<p>②Post的发送数据<br>数据填写到body里面，按照接口文档的内容选择的发送—-请求头有写明<br>方式：form-data、x-www-form-urlencoded、raw、binary（具体可自行百度）<br>其中row又分为text、js、josn、html、xml</p>
<p>③注意：get和post类型接口的区别和特点<br>Get：数据直接在URL显示出来<br>     区别：输入参数长度有限制，所有数据直接显示在URL中可见，不安全。<br>     特点：一般使用get型的接口，是从数据库中去读取数据、查询比较多。<br>Post：post和get相反，数据输入于body中<br>     区别：输入的数据内容、大小没有限制，数据不能直接看到，更安全。<br>     特点：一般是对数据库写入、修改比较多。</p>
<p>④    Josn的格式：<br>{“key1”:“value”， “key2”:“value”， “key3”:{ “key”:“value”} }<br>▪前后用{}包裹起来<br>▪由key和value组成—-key为参数，value为值，中间用“：”隔开<br>▪所有符号为英文标点符号<br>▪两个参数用“，”隔开，最后一个不用<br>▪JOSN格式里可以套用JOSN格式</p>
<h3 id="3-状态码的含义"><a href="#3-状态码的含义" class="headerlink" title="(3)状态码的含义"></a>(3)状态码的含义</h3><p>①常见状态码：<br>200：代表这个借口运行正常<br>400：接口发送的参数不正确<br>404：接口地址输入不正确<br>405：接口类型不正确<br>500：代表接口的代码有问题，内部服务器错误<br>②其他状态码：401,402,303,406,408…（可自行百度）</p>
<h2 id="4、postman传递token参数，实现接口测试"><a href="#4、postman传递token参数，实现接口测试" class="headerlink" title="4、postman传递token参数，实现接口测试"></a>4、postman传递token参数，实现接口测试</h2><p>⑴这里先设置环境变量，系统入口url在每个接口中都一样，设置成环境变量，便于维护。环境变量集名：rds。两个变量：url , token （token是为了下一步准准备）。<br>⑵新建登录接口请求，设置params(登录接口的账户&amp;密码)。发请求到登录后，获取token。<br>⑶在Tests里面编写脚本，将获取到的token设置到环境变量token中。 同时Tests里面也可以加断言，判断该接口测试的结果。<br>⑷登录接口测试完后，查看环境变量，token值已被保存。</p>
<h2 id="5、变量"><a href="#5、变量" class="headerlink" title="5、变量"></a>5、变量</h2><p>分类：可分为全局变量和局部变量<br>区别：局部变量要选择变量才能生效<br>      全局变量不选择也会生效<br>步骤：<br>第一步：点击眼睛按钮进入局部变量<br>第二步：点击Add添加局部变量<br>第三步：点击输入参数（VARIABLE和CURRENT VALUE）<br>第四步：点击Add保存参数<br>第五步：点击切换参数<br>第六步：将要参数改为变量:替换为｛｛参数名｝｝后，点击send运行，得出结果</p>
<h2 id="6、自定义脚本：JavaScript"><a href="#6、自定义脚本：JavaScript" class="headerlink" title="6、自定义脚本：JavaScript"></a>6、自定义脚本：JavaScript</h2><h3 id="1-脚本的区别："><a href="#1-脚本的区别：" class="headerlink" title="(1)脚本的区别："></a>(1)脚本的区别：</h3><p>Pre-request Script：控制发送的数据<br>Tests：控制返回的结果</p>
<h3 id="2-常用代码："><a href="#2-常用代码：" class="headerlink" title="(2)常用代码："></a>(2)常用代码：</h3><p>官方说明文档：<a href="https://learning.postman.com/docs/postman/scripts/postman-sandbox-api-reference/" target="_blank" rel="noopener">https://learning.postman.com/docs/postman/scripts/postman-sandbox-api-reference/</a></p>
<p>常用代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取response返回内容</span></span><br><span class="line"><span class="keyword">var</span> rsb = responseBody; <span class="comment">// 是字符串格式</span></span><br><span class="line"><span class="keyword">var</span> res = JOSN.parse(responseBody);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line"><span class="keyword">var</span> v = pm.environment.get(<span class="string">"变量名称"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置环境变量 只能存储字符串，如果是对象的话则无法在下次运行时获取到内容</span></span><br><span class="line"><span class="comment">// 如需要存储JSON数据，可以用JSON.stringify(..)存储，再用JSON.parse(..)转化为对象使用</span></span><br><span class="line">pm.environment.set(<span class="string">"变量名称"</span>, 变量内容);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 清除某个环境变量</span></span><br><span class="line">pm.environment.unset(<span class="string">"环境变量名"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取全局变量和普通变量</span></span><br><span class="line"><span class="keyword">var</span> gb = pm.globals.get(<span class="string">"全局变量名"</span>);</span><br><span class="line"><span class="keyword">var</span> nm = pm.variables.get(<span class="string">"普通变量名"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Javascript 获取变量类型</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> pm.enviroment );</span><br></pre></td></tr></table></figure>
<h2 id="7、断言：自动判断是否成功"><a href="#7、断言：自动判断是否成功" class="headerlink" title="7、断言：自动判断是否成功"></a>7、断言：自动判断是否成功</h2><p>官方说明文档：<a href="https://learning.getpostman.com/docs/postman/scripts/test_examples/" target="_blank" rel="noopener">https://learning.getpostman.com/docs/postman/scripts/test_examples/</a><br>断言语句参考：<a href="https://www.cnblogs.com/liruxian/p/10001539.html" target="_blank" rel="noopener">https://www.cnblogs.com/liruxian/p/10001539.html</a></p>
<p>举例说明：解析响应正文，并判断statusCode的值是200，message的值是”Success”<br>操作：我们需要解析JSON串了，所以，在SNIPPETS中找到”Response body:JSON value check”并点击，在其左边，断言代码自动添加，对代码进行修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pm.expect(jsonData.value).to.eql(<span class="number">200</span>);    <span class="comment">//判断statusCode的值是200</span></span><br><span class="line">pm.expect(jsonData.value).to.eql(<span class="string">'Success'</span>);    <span class="comment">//判断message的值是”Success”</span></span><br></pre></td></tr></table></figure>
<p>点击Send，发送请求，PASS表示断言通过，FAIL表示断言失败。</p>
]]></content>
      <tags>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>博客地址拒绝我的访问</title>
    <url>/2020/08/04/GitHub-rejects-connection-request/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="问题：我的博客（https-intend-xie-github-io-）被拒绝访问"><a href="#问题：我的博客（https-intend-xie-github-io-）被拒绝访问" class="headerlink" title="问题：我的博客（https://intend-xie.github.io/）被拒绝访问"></a>问题：我的博客（<a href="https://intend-xie.github.io/）被拒绝访问" target="_blank" rel="noopener">https://intend-xie.github.io/）被拒绝访问</a></h2><p>您的连接不是私密连接<br>攻击者可能会试图从 <strong>intend-xie.github.io</strong> 窃取您的信息（例如：密码、通讯内容或信用卡信息）。了解详情<br>NET::ERR_CERT_AUTHORITY_INVALID<br><img src= "/img/loading.gif" data-src="/images/GitHub-rejects-connection-request1.png" alt="问题"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、在cmd中，ping intend-xie.github.io,得到IP<br><img src= "/img/loading.gif" data-src="/images/GitHub-rejects-connection-request2.png" alt="步骤1"><br>2、将其ip和域名添加到hosts文件（目录：C:\Windows\System32\drivers\etc）中<br><img src= "/img/loading.gif" data-src="/images/GitHub-rejects-connection-request3.png" alt="步骤2-1"><br><img src= "/img/loading.gif" data-src="/images/GitHub-rejects-connection-request4.png" alt="步骤2-2"><br>3、    如果还不行，可通过打开Dns检测|Dns查询 - 站长工具：<a href="http://tool.chinaz.com/dns" target="_blank" rel="noopener">http://tool.chinaz.com/dns</a><br>4、在检测输入栏中输入博客地址（intend-xie.github.io）<br><img src= "/img/loading.gif" data-src="/images/GitHub-rejects-connection-request5.png" alt="步骤3、4"><br>5、把检测列表里某个IP（对应TTL值最小和最大的IP我尝试了都可以，其他有兴趣可以试试）输入到hosts里，并对应写上博客地址<br><img src= "/img/loading.gif" data-src="/images/GitHub-rejects-connection-request6.png" alt="步骤5"><br>6、问题的思路<br>通过下面两个链接进行了解解决，具体可进行查看：<br><a href="https://www.jianshu.com/p/5b72495f4548" target="_blank" rel="noopener">https://www.jianshu.com/p/5b72495f4548</a><br><a href="https://segmentfault.com/q/1010000010264567" target="_blank" rel="noopener">https://segmentfault.com/q/1010000010264567</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Ngrok进行内网穿透</title>
    <url>/2020/07/19/Ngrok/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<p><strong>1、什么是Ngrok</strong></p>
<p>Ngrok 是一个反向代理，通过在公共端点和本地运行的 Web 服务器之间建立一个安全的通道，实现内网主机的服务可以暴露给外网。Ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，所以 Ngrok可以很方便地协助服务端程序测试。Ngrok希望帮人节省更多的时间去编程。只需一个命令，便可将一个本地服务器暴露在NAT或防火墙后面的互联网。</p>
<p><strong>2、注册账号</strong></p>
<p>1、进入网站：<a href="http://www.ngrok.cc/" target="_blank" rel="noopener">http://www.ngrok.cc/</a><br>2、点击注册，填写信息<br><img src= "/img/loading.gif" data-src="/images/ngrok1.png" alt="网站"><br><img src= "/img/loading.gif" data-src="/images/ngrok2.png" alt="注册"></p>
<p><strong>3、开通隧道</strong></p>
<p>1、进行登录，选择隧道管理—开通隧道–美国Ngrok免费服务器（立即购买）<br>2、填写信息，点击确定添加，点击确定开通<br><img src= "/img/loading.gif" data-src="/images/ngrok3.png" alt="进入页面"><br><img src= "/img/loading.gif" data-src="/images/ngrok4.png" alt="开通"></p>
<p><strong>4、下载启动服务器</strong></p>
<p>1、点击客户端下载，跳转至下载页面，选择自己的对应系统（我的电脑为windows64位）进行下载<br>2、下载好后，进行解压，打开文件夹：windows_amd64，打开Sunny-Ngrok启动工具<br>3、在Sunny-Ngrok启动工具，输入隧道id，点击enter键，启动成功，可进行远程访问<br><img src= "/img/loading.gif" data-src="/images/ngrok5.png" alt="客户端下载"><br><img src= "/img/loading.gif" data-src="/images/ngrok6.png" alt="下载"><br><img src= "/img/loading.gif" data-src="/images/ngrok7.png" alt="输入ID"><br><img src= "/img/loading.gif" data-src="/images/ngrok8.png" alt="启动成功"></p>
]]></content>
      <tags>
        <tag>Ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD命令模式使用pip提示Did not provide a command</title>
    <url>/2020/06/21/Python-pip/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<p>问题：python安装后pip用不了，但是cmd命令窗口提示：Did not provide a command<br><img src= "/img/loading.gif" data-src="/images/Python-pip1.png" alt="问题"><br>首先，使用where pip找到pip的安装目录，我的目录为第三个，D:\Python\Python38\Scripts\pip.exe<br><img src= "/img/loading.gif" data-src="/images/Python-pip2.png" alt="pip目录"><br>其次，配置环境变量<br>打开环境变量配置窗口：此电脑–》属性–》左上侧的高级系统设置–》高级–》环境变量<br>在之前的环境变量Path最后添加，如果最后已经有英文的“;”分号，则不需要添加分号了，直接添加你的目录。如果没有则在后面添加英文分号“;”和你的pip目录，我的为“D:\Python\Python38\Scripts\”，添加完成之后，最好是在内容的最后面直接添加一个英文的“;”，习惯问题，方便下次配置其他环境变量时忘记添加而造成不能使用。<br><img src= "/img/loading.gif" data-src="/images/Python-pip3.png" alt="修改环境变量"><br>因此每次使用pip命令安装东西的时候都需要先进入到pip所在目录去执行pip install。—-这样的操作比较麻烦。<br>因此我在使用pip命令的时候做了区分，我直接使用pip3(因为我的版本是3.0的)，发现环境变量配置的确实没有问题，原来使用pip3来执行装就可以了<br><img src= "/img/loading.gif" data-src="/images/Python-pip4.png" alt="区分pip"><br>所以在安装的时候使用pip3 install 来进行安装就可以了。<br>注意：如果您的版本是pip2，那么就用pip2 install来安装就可以了。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装卸载dstat</title>
    <url>/2020/08/30/UbuntuInstall/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、进行监理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hairui@hadoop:~$ dstat</span><br><span class="line">The program <span class="string">'dstat'</span> is currently not installed.you can install it by typing: apt install dstat</span><br></pre></td></tr></table></figure>
<p>2、发现没有安装dstat，进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hairui@hadoop:~$ sudo apt install dstat</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/UbuntuInstall1.png" alt="img"></p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>1、    查看安装的所有软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hairui@hadoop:dpkg –list</span><br></pre></td></tr></table></figure>
<p>2、    在终端中找到你需要卸载的软件的名称，列表是按照首字母排序的。<br><img src= "/img/loading.gif" data-src="/images/UbuntuInstall2.png" alt="img"><br>3、    在终端上输入命令sudo apt-get –purge remove 包名（–purge是可选项，写上这个属性是将软件及其配置文件一并删除，如不需要删除配置文件，可执行sudo apt-get remove 包名） ，此处我要删除的是dstat ，那么在终端执行下方语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hairui@hadoop:sudo apt-get --purge remove dstat</span><br></pre></td></tr></table></figure>
<p>4、    执行过程中，会提示你是否真的要删除（继续执行删除命令），在终端输入y ，然后回车，删除程序继续执行。<br><img src= "/img/loading.gif" data-src="/images/UbuntuInstall3.png" alt="img"></p>
<p>参考博客：<br><a href="https://blog.csdn.net/luckydog612/article/details/80877179" target="_blank" rel="noopener">https://blog.csdn.net/luckydog612/article/details/80877179</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo发生error：spawn failed错误的解决方法</title>
    <url>/2020/07/19/hexo-deploy-problem/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<p><strong>问题描述：</strong></p>
<p>部署博客是出现出现错误：<br>Error: Spawn failed<br>at ChildProcess.<anonymous> (D:\Develop\VSCode-workspace\intendblog\node_modules_<a href="mailto:hexo-util@1.9.1">hexo-util@1.9.1</a>@hexo-util\lib\spawn.js:51:21)<br>at ChildProcess.emit (events.js:310:20)<br>at ChildProcess.cp.emit (D:\Develop\VSCode-workspace\intendblog\node_modules_<a href="mailto:cross-spawn@7.0.3">cross-spawn@7.0.3</a>@cross-spawn\lib\enoent.js:34:29)<br>at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12) </p>
<p><strong>解决办法：</strong></p>
<ol>
<li>删除.deploy_git文件夹;</li>
<li>然后，依次执行：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo s后,访问页面显示Cannot GET /</title>
    <url>/2020/08/20/npm-erp/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>hexo s后,访问页面显示Cannot GET /<br><img src= "/img/loading.gif" data-src="/images/npm-erp1.png" alt="img"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>排查</strong><br>(1)判断public目录下xxx文件是否存在。<br>（我的错误是 Cannot GET /，因此在public目录下寻找index.html是否存在。）<br>(2)发现index.html不存在，那么执行执行npm audit fix，查看是否少了什么组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PS D:\Develop\VSCode-workspace\intendblog&gt; npm audit fix</span><br><span class="line">npm ERR! code EAUDITNOLOCK</span><br><span class="line">npm ERR! audit Neither npm-shrinkwrap.json nor package-lock.json found:</span><br><span class="line"> Cannot audit a project without a lockfile</span><br><span class="line">npm ERR! audit Try creating one first <span class="keyword">with</span>: npm i --package-lock-only</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\</span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-20</span>T14_06_31_854Z-debug.log</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm ERR! audit Neither npm-shrinkwrap.json nor package-lock.json found:</span><br><span class="line"> Cannot audit a project without a lockfile</span><br></pre></td></tr></table></figure>
<p>（1）上方语句，意思是没有package.json这个文件，所以新建一个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init --yes</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm ERR! audit Try creating one first <span class="keyword">with</span>: npm i --package-lock-only</span><br></pre></td></tr></table></figure>
<p>（2）上方语句，使用 npm i –package-lock-only下载package-lock.json</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i --package-lock-only</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://www.jianshu.com/p/af83fc73e525" target="_blank" rel="noopener">https://www.jianshu.com/p/af83fc73e525</a><br><a href="https://blog.csdn.net/TalonZhang/article/details/88543497" target="_blank" rel="noopener">https://blog.csdn.net/TalonZhang/article/details/88543497</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git+github+hexo学习</title>
    <url>/2020/06/21/git-github-hexo/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="1、什么是版本控制"><a href="#1、什么是版本控制" class="headerlink" title="1、什么是版本控制"></a>1、什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。<br>•    实现跨区域多人协同开发<br>•    追踪和记载一个或者多个文件的历史记录<br>•    组织和保护你的源代码和文档<br>•    统计工作量<br>•    并行开发、提高开发效率<br>•    跟踪记录整个软件的开发过程<br>•    减轻开发人员的负担，节省时间，同时降低人为错误<br>简单说就是用于管理多人协同开发项目的技术。</p>
<h2 id="2、SVN与Git优缺点比较"><a href="#2、SVN与Git优缺点比较" class="headerlink" title="2、SVN与Git优缺点比较"></a>2、SVN与Git优缺点比较</h2><h3 id="（1）SVN优缺点"><a href="#（1）SVN优缺点" class="headerlink" title="（1）SVN优缺点"></a>（1）SVN优缺点</h3><p>优点：<br>1、    管理方便，逻辑明确，符合一般人思维习惯。<br>2、 易于管理，集中式服务器更能保证安全性。<br>3、 代码一致性非常高。<br>4、 适合开发人数不多的项目开发。<br>缺点：<br>1、 服务器压力太大，数据库容量暴增。<br>2、 如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。<br>3、 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</p>
<h3 id="（2）Git优缺点"><a href="#（2）Git优缺点" class="headerlink" title="（2）Git优缺点"></a>（2）Git优缺点</h3><p>优点：<br>1、适合分布式开发，强调个体。<br>2、公共服务器压力和数据量都不会太大。<br>3、速度快、灵活。<br>4、任意两个开发者之间可以很容易的解决冲突。<br>5、离线工作。<br>缺点：<br>1、学习周期相对而言比较长。<br>2、不符合常规思维。<br>3、代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</p>
<h2 id="3、设置用户名与邮箱（用户标识，必要）"><a href="#3、设置用户名与邮箱（用户标识，必要）" class="headerlink" title="3、设置用户名与邮箱（用户标识，必要）"></a>3、设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：<br>git config –global user.name “mingcheng”  #名称<br>git config –global user.email youxiang   #邮箱<br>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>
<h2 id="4、创建SSH-Key"><a href="#4、创建SSH-Key" class="headerlink" title="4、创建SSH Key"></a>4、创建SSH Key</h2><p>第一步：在用户主目录（C:\Users\Administrator）下，看看有没有.ssh文件，如果有，再看文件下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接到下一步。如果没有，打开Git Bash，输入命令，创建SSH Key<br>ssh-keygen -t rsa -C “邮箱” //注册GitHub的邮箱<br>第二步：创建成功，再去用户主目录里找到.ssh文件夹，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以公开。<br>第三步：到GitHub上，打开“Account settings”–“SSH Keys”页面，然后点击“Add SSH Key”，填上Title，在Key文本框里粘贴 id_rsa.pub文件里的全部内容。点“Add Key”，你就应该看到已经添加的Key，可以添加多个Key<br>第四步：验证是否成功，在git bash里输入下面的命令ssh -T <a href="mailto:git@github.com">git@github.com</a>，如果初次设置的话，会出现如下界面，输入yes 同意即可。</p>
<h2 id="5、上传自己的文件到GitHub远程仓库上"><a href="#5、上传自己的文件到GitHub远程仓库上" class="headerlink" title="5、上传自己的文件到GitHub远程仓库上"></a>5、上传自己的文件到GitHub远程仓库上</h2><p>第一步：cd进入你放项目文件的地址，我的地址在D:\MYFILE\graduation\study\项目程序<br>第二步：输入git init，当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹）<br>第三步：输入git add . ，将项目上所有的文件添加到仓库中的意思<br>第四步：输入git commit -m “first commit”，表示你对这次提交的注释<br>第五步输入git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上，<br>如果想要修改先使用git remote rm origin 删除关联<br>最后一步，输入git push -u origin master，这是把代码上传到github仓库的意思。<br>Or git push origin master推送最新修改<br>执行完后，如果没有异常，会等待几秒，然后跳出一个让你输入Username和Password 的窗口，你只要输人github的登录账号和密码就行了。</p>
<p>注意：遇到git remote地址不对时，进行以下操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、查看当前配置有哪些远程仓库</span></span><br><span class="line">$ git remote </span><br><span class="line">origin</span><br><span class="line"><span class="comment">//2、执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  ps:<span class="comment">//github.com/Intend-xie/Intend-xieblog (fetch)</span></span><br><span class="line">origin  ps:<span class="comment">//github.com/Intend-xie/Intend-xieblog (push)</span></span><br><span class="line"><span class="comment">//3、修改地址</span></span><br><span class="line">$ git remote <span class="keyword">set</span>-url origin https://github.com/Intend-xie/Intend-xieblog.git</span><br><span class="line">//4、再次查看</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/Intend-xie/Intend-xieblog.git (fetch)</span><br><span class="line">origin  https://github.com/Intend-xie/Intend-xieblog.git (push)</span><br></pre></td></tr></table></figure>

<h2 id="6、Git和hexo的连接"><a href="#6、Git和hexo的连接" class="headerlink" title="6、Git和hexo的连接"></a>6、Git和hexo的连接</h2><p>第一步：每个git账号都可以有一个用于展示个人博客的静态网站，且仓库名固定，如s <git_username>.github.io，创建一个远程仓库<br>第二步：仓库创建完成后，得到仓库地址URL，修改配置文件 /_config.yml 相关的配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">    repo: <span class="xml"><span class="tag">&lt;<span class="name">repository_url</span>&gt;</span>  # git远程仓库地址</span></span><br><span class="line">    branch: &lt;branch_name&gt;  # 分支名，一般是master</span><br></pre></td></tr></table></figure>
<p>第三步：将工程推到git上，输入命令hexo clean清除缓存，hexo deploy进行部署，执行hexo的deploy部署命令推到git上时，目录结构跟本地工程的不同，也就是编译过。，<br>第四步：为了便于维护，可以再建一个git远程仓库，执行git命令把工程推上去，用来管理工程源代码。</p>
<h2 id="7、运维必须要会用的-10-个-Git-命令"><a href="#7、运维必须要会用的-10-个-Git-命令" class="headerlink" title="7、运维必须要会用的 10 个 Git 命令"></a>7、运维必须要会用的 10 个 Git 命令</h2><p>检查：<br>先了解一下如何检查改动痕迹。<br>git diff——查看所有本地文件的改动。只改动一个文件的话可以在命令后添加文件名。<br>git log——查看所有提交历史。还可用于带有 git log –p my_file 的文件，输入 q 退出。<br>git blame my file——了解谁在什么时候对 my_file 做了什么样的改动。<br>git reflog——显示本地代码库 HEAD 的更改日志。这个命令很适合查找丢失的工作。<br>用 Git 进行检查并不麻烦。相比之下，Git 中有不少删除和撤销提交以及文件改动的操作。</p>
<p>撤销：<br>可以用 git reset、git checkout 和 git revert 撤销在代码库中所做的改动，这些命令可能有点难理解。<br>git reset 和 git checkout 既可用于提交也可用于单个文件的修改，而 git revert 只能用在提交层面。如果你只需要处理尚未合并到协作远程工作的本地提交，你可以使用这三者中任何一条命令。如果是协同工作且需要撤销远程分支中的提交，那么就用 git revert。<br>这些命令中的每一条都有多个参数。以下是常见的用法：<br>git reset –-hard HEAD——撤销最近提交以来暂存区和非暂存区的改动。<br>指定不同的提交而不是 HEAD，以撤销自这条提交以来的更改。–hard 指的是撤销暂存区和非暂存区的更改。<br>要确保你撤销的不是协作伙伴所依赖的远程分支的提交。<br>git checkout my commit——从 my_commit 中撤销非暂存区的改动。<br>HEAD 常用在 my_commit，用来撤销最近一次提交以来在本地工作目录的改动。<br>checkout 最适合用于仅限于本地的撤销。它不会破坏你的协作伙伴所依赖的远程分支的提交历史。<br>如果你将 checkout 用在分支而不是提交上，HEAD 将会切换到指定分支，并更新成匹配的工作目录。这是 checkout 命令更常见的用法。<br>Git revert my commit——撤销 my_commit 中的更改。当用 revert 撤销改动时，它会产生新的提交。<br>对协作项目而言，revert 是很安全的，因为它不会覆盖其他用户分支可能依赖的历史记录。<br>有时候你只想删除本地目录中的未追踪文件。例如，也许你运行的代码在版本库中创建了许多你不需要的不同类型的文件。你可以一键清除它们！<br>Git clean –n——删除本地工作目录中的未追踪文件。<br>–n 表示试运行，在试运行中什么都不会删除。<br>-f 表示实际删除文件。<br>-d 表示删除未追踪的目录。<br>默认情况下不会删除 .gitignore 中的未追踪文件，但这种行为是可以更改的。<br>现在你已经知道了 Git 中用于撤销操作的命令，接下来我们再看两条可以有序排列文件的命令。</p>
<p>整理：<br>Git commit –amend——将暂存区的更改添加到最近一次提交中。<br>如果暂存区中什么都没有，你可以用该命令编辑最新的提交信息。只有在提交尚未整合到远程主分支中时才使用该命令！<br>Git push my remote –tags——将所有本地标记发送到远程版本库中。适用于版本变更。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个人博客添加鼠标点击效果</title>
    <url>/2020/08/21/MouseClickEffect/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。</p>
<h2 id="鼠标点击出现桃心"><a href="#鼠标点击出现桃心" class="headerlink" title="鼠标点击出现桃心"></a>鼠标点击出现桃心</h2><p>（1）在Hexo博客下找到自己使用的主题在文件夹source下新建love.js，love.js文件内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>（2）在主题文件夹下的layout文件夹下的_layout.ejs（我自己的是layout.ejs文件）配置文件里面的<head></head>标签里添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/love.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="鼠标点击出现爆炸烟花"><a href="#鼠标点击出现爆炸烟花" class="headerlink" title="鼠标点击出现爆炸烟花"></a>鼠标点击出现爆炸烟花</h2><p>（1）在\codeblog\themes\next6\source\js下新建文件firework.js文件，其中加入代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>
<p>在主题文件夹下的layout文件夹下的_layout配置文件里面的<head></head>标签里添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 爆炸红心效果 --&gt;</span><br><span class="line">&lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"fireworks"</span> style=<span class="string">"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"</span> &gt;&lt;<span class="regexp">/canvas&gt; </span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" src="</span><span class="comment">//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; </span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/firework.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>参考博客：<br><a href="https://www.cnblogs.com/songsongblue/p/10911387.html" target="_blank" rel="noopener">https://www.cnblogs.com/songsongblue/p/10911387.html</a><br><a href="https://blog.csdn.net/C_acgl/article/details/86555826" target="_blank" rel="noopener">https://blog.csdn.net/C_acgl/article/details/86555826</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2.7和3.7区别</title>
    <url>/2020/07/14/Differences-in-Python/</url>
    <content><![CDATA[<p>此文仅是本人学习笔记。<br>文章来源：<a href="https://www.cnblogs.com/sqm724/p/13294061.html?utm_source=tuicool" target="_blank" rel="noopener">https://www.cnblogs.com/sqm724/p/13294061.html?utm_source=tuicool</a></p>
<p><strong>区别一:print语法使用</strong></p>
<p>Python2.7  print语法使用  &gt;&gt;&gt; print “Hello Python”<br>Python3.7  print语法使用  &gt;&gt;&gt; print(“Hello Python”)</p>
<p>例子:在Python 3.7.0使用双引号触发SyntaxError异常机制 提示Did you mean </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">print <span class="string">"Hello Python3.7"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Hello Python3.7"</span>)</span><br></pre></td></tr></table></figure>
<p>print 换行和不换行区别<br>python 2.7 print 不换行使用”,”即可<br>python 3.7 print 不换行使用end=””</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="string">"a"</span></span><br><span class="line">y = <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line">print(y,end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<p><strong>区别二: raw_input()和input()</strong></p>
<p>Python 2.7  raw_input()  input() 都存在 可使用    raw_input()接收字符串string  input()接收数字int /flot.<br>Python 3.7  raw_input()不存在  仅存在input()   两者合并  接收任意格式 返回string</p>
<p><strong>区别三: 函数cmp()</strong></p>
<p>python 2.7   cmp(x,y)函数用于比较2个对象，如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1<br>python3.7    cmp()已经不存在了,如果你需要实现比较功能，需要引入 operator 模块，适合任何对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">operator.eq(<span class="string">'hello'</span>, <span class="string">'name'</span>);   <span class="comment">//False</span></span><br><span class="line">operator.eq(<span class="string">'hello'</span>, <span class="string">'hello'</span>);   <span class="comment">//True</span></span><br></pre></td></tr></table></figure>

<p><strong>区别四:string 字母 大小写字符串</strong></p>
<p>string.letters:包含所有字母（大写或小写）的字符串<br>Python 3.0中，string.ascii_letters.</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
